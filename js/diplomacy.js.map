{"version":3,"names":[],"mappings":"","sources":["diplomacy.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst diplomacy = require(\"../src/jsDiplomacy\");\nwindow.diplomacy = diplomacy;\n\n},{\"../src/jsDiplomacy\":4}],2:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graph_1 = require(\"./graph\");\nconst { LabeledEdge, LabeledUndirectedGraph } = graph_1.graph;\nvar board;\n(function (board) {\n    /**\n     * Name of atomic components (e.g., provinces)\n     */\n    class Name {\n        /**\n         * @param name The name\n         * @param abbreviatedName The abbreviated name. name is used if this param is not specified.\n         */\n        constructor(name, abbreviatedName) {\n            this.name = name;\n            this.abbreviatedName = abbreviatedName || name;\n        }\n        toString() {\n            return this.abbreviatedName;\n        }\n    }\n    board.Name = Name;\n    /**\n     * Province in Diplomacy map\n     */\n    class Province {\n        /**\n         * @param name The name of this province\n         * @param homeOf\n         *   The power that has this province as a home country.\n         *   This is a neutral province if null is set.\n         * @param isSupplyCenter The flag whether this is a supply center or not.\n         */\n        constructor(name, homeOf, isSupplyCenter) {\n            this.name = name;\n            this.homeOf = homeOf;\n            this.isSupplyCenter = isSupplyCenter || false;\n        }\n        toString() {\n            if (this.isSupplyCenter) {\n                return `${this.name}*`;\n            }\n            else {\n                return this.name.toString();\n            }\n        }\n    }\n    board.Province = Province;\n    /**\n     * Location in Diplomacy map. Each province is expected to have 1 location at least.\n     */\n    class Location {\n        /**\n         * @param name The name of this location. It is usually same as the name of the province\n         * @param province The province that this location is in.\n         * @param militaryBranches The set of military branches that can enter this location.\n         */\n        constructor(name, province, militaryBranches) {\n            this.name = name;\n            this.province = province;\n            this.militaryBranches = new Set([...militaryBranches]);\n        }\n        toString() {\n            return `${this.name}`;\n        }\n    }\n    board.Location = Location;\n    /**\n     * Unit of Diplomacy\n     */\n    class Unit {\n        /**\n         * @param militaryBranch The military branch of this unit.\n         * @param location The location where this unit is in.\n         * @param power The power that has this unit.\n         */\n        constructor(militaryBranch, location, power) {\n            this.militaryBranch = militaryBranch;\n            this.location = location;\n            this.power = power;\n            console.assert(this.location.militaryBranches.has(militaryBranch));\n        }\n        toString() {\n            return `${this.militaryBranch} ${this.location}`;\n        }\n    }\n    board.Unit = Unit;\n    /**\n     * Relation between board.Location\n     */\n    class MapEdge extends graph_1.graph.LabeledEdge {\n        /**\n         * @param n1 The end point 1.\n         * @param n2 The end point 2.\n         * @param label The set of military branches.\n         */\n        constructor(n1, n2, militaryBranches) {\n            super(n1, n2, new Set([...militaryBranches]));\n        }\n    }\n    board.MapEdge = MapEdge;\n    /**\n     * Map of Diplomacy\n     */\n    class DiplomacyMap {\n        /**\n         * @param map The labeled graph that represents the map.\n         */\n        constructor(map) {\n            this.map = map;\n            this.locations = this.map.nodes;\n            this.provinces = new Set();\n            this.provinceToLocation = new Map();\n            this.locations.forEach(elem => {\n                this.provinces.add(elem.province);\n                if (!this.provinceToLocation.has(elem.province)) {\n                    this.provinceToLocation.set(elem.province, new Set());\n                }\n                const locs = this.provinceToLocation.get(elem.province);\n                if (locs) {\n                    locs.add(elem);\n                }\n            });\n            this.powers = new Set();\n            this.provinces.forEach(province => {\n                if (province.homeOf) {\n                    this.powers.add(province.homeOf);\n                }\n            });\n        }\n        /**\n         * @param province The province\n         * @return The set of locations that the province has.\n         */\n        locationsOf(province) {\n            return this.provinceToLocation.get(province) || new Set();\n        }\n        /**\n         * @param province The province\n         * @param militaryBranch The military branch\n         * @return The set of provinces that the military branch in the province can move.\n         */\n        movableProvincesOf(province, militaryBranch) {\n            const retval = new Set();\n            const locations = this.locationsOf(province);\n            this.locationsOf(province).forEach(location => {\n                this.movableLocationsOf(location, militaryBranch).forEach(location => {\n                    retval.add(location.province);\n                });\n            });\n            return retval;\n        }\n        /**\n         * @param {!board.Location} location - The location\n         * @param {!(string|Object)} militaryBranch - The military branch\n         * @return {!Set.<board.Location>} -\n         *   The set of locations that the military branch in the location can move.\n         */\n        movableLocationsOf(location, militaryBranch) {\n            return new Set([...this.map.neighborsOf(location)]\n                .filter(elem => elem[1].has(militaryBranch)).map(elem => elem[0]));\n        }\n    }\n    board.DiplomacyMap = DiplomacyMap;\n    class Board {\n        /**\n         * @param map\n         * @param state\n         * @param units The units that are in this board\n         * @param unitStatuses The state of each unit (e.g., the unit was dislodged)\n         * @param provinceStatuses\n         *   The state of each province (e.g., standoff was occurred, this province is occupied by X)\n         */\n        constructor(map, state, units, unitStatuses, provinceStatuses) {\n            this.map = map;\n            this.state = state;\n            this.units = new Set([...units]);\n            this.unitStatuses = new Map([...unitStatuses]);\n            this.provinceStatuses = new Map([...provinceStatuses]);\n        }\n    }\n    board.Board = Board;\n})(board = exports.board || (exports.board = {}));\n\n},{\"./graph\":3}],3:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graph;\n(function (graph) {\n    /**\n     * Implementation of IEdge\n     */\n    class Edge {\n        constructor(n0, n1) {\n            this.n0 = n0;\n            this.n1 = n1;\n        }\n    }\n    graph.Edge = Edge;\n    /**\n     * Implementation of ILabeledEdge\n     */\n    class LabeledEdge extends Edge {\n        constructor(n0, n1, label) {\n            super(n0, n1);\n            this.label = label;\n        }\n    }\n    graph.LabeledEdge = LabeledEdge;\n    /**\n     * Undirected graph with labeled edges\n     */\n    class LabeledUndirectedGraph {\n        /**\n         * @param edges The set of edges.\n         * @param nodes The set of nodles.\n         */\n        constructor(edges, nodes) {\n            this.edges = new Set([...edges]);\n            if (!nodes) {\n                this.nodes = new Set();\n                this.edges.forEach(edge => {\n                    this.nodes.add(edge.n0);\n                    this.nodes.add(edge.n1);\n                });\n            }\n            else {\n                this.nodes = new Set([...nodes]);\n            }\n            this.neighborLists = new Map();\n            this.nodes.forEach(node => {\n                const xs1 = Array.from(this.edges).filter(edge => edge.n0 === node).map(edge => [edge.n1, edge.label]);\n                const xs2 = Array.from(this.edges).filter(edge => edge.n1 === node).map(edge => [edge.n0, edge.label]);\n                const xs = xs1.concat(xs2);\n                this.neighborLists.set(node, new Set(xs));\n            });\n        }\n        /**\n         * @param node - The target node\n         * @return he set of nodes that are neighbors of the node.\n         */\n        neighborsOf(node) {\n            return this.neighborLists.get(node) || new Set();\n        }\n    }\n    graph.LabeledUndirectedGraph = LabeledUndirectedGraph;\n    /**\n     * Directed graph\n     */\n    class DirectedGraph {\n        /**\n         * @param nodes The set of nodes.\n         * @param edges The set of edges.\n         */\n        constructor(edges, nodes) {\n            this.edges = new Set([...edges]);\n            if (!nodes) {\n                this.nodes = new Set();\n                this.edges.forEach(edge => {\n                    this.nodes.add(edge.n0);\n                    this.nodes.add(edge.n1);\n                });\n            }\n            else {\n                this.nodes = new Set([...nodes]);\n            }\n            this.neighborLists = new Map();\n            this.nodes.forEach(node => {\n                const os = Array.from(this.edges).filter(edge => edge.n0 === node).map(edge => edge.n1);\n                const is = Array.from(this.edges).filter(edge => edge.n1 === node).map(edge => edge.n0);\n                this.neighborLists.set(node, [new Set(os), new Set(is)]);\n            });\n        }\n        outgoingNodesOf(node) {\n            return (this.neighborLists.get(node) || [new Set(), new Set()])[0];\n        }\n        incomingNodesOf(node) {\n            return (this.neighborLists.get(node) || [new Set(), new Set()])[1];\n        }\n        /**\n         * @return The cycle that is contained this graph. If there are no cycles, returns null.\n         */\n        getCycle() {\n            const visit = (node, path, state) => {\n                state.set(node, true);\n                let cycle = null;\n                for (let v of this.outgoingNodesOf(node)) {\n                    if (!state.get(v)) {\n                        const p = [...path];\n                        p.push(v);\n                        const c = visit(v, p, state);\n                        if (c) {\n                            cycle = c;\n                            break;\n                        }\n                    }\n                    else {\n                        cycle = path.slice(path.indexOf(v));\n                        break;\n                    }\n                }\n                return cycle;\n            };\n            let cycle = null;\n            for (let node of [...this.nodes]) {\n                const state = new Map([...this.nodes].map(node => [node, false]));\n                if (!state.get(node)) {\n                    const c = visit(node, [node], state);\n                    if (c) {\n                        cycle = c;\n                        break;\n                    }\n                }\n            }\n            return cycle;\n        }\n        /**\n         * Deletes a node.\n         * @param node The node to be deleted.\n         * @return The directed graph that deletes the node.\n         */\n        deleteNode(node) {\n            const nodes = new Set([...this.nodes].filter(n => n !== node));\n            const edges = [...this.edges].filter(edge => edge.n0 !== node && edge.n1 !== node);\n            return new DirectedGraph(edges, nodes);\n        }\n        /**\n         * Merges nodes into one node.\n         * @param nodes The nodes to be merged.\n         * @return The directed graph that merges the nodes into one node.\n         */\n        mergeNodes(target) {\n            const nodes = new Set([...this.nodes]);\n            let mergedValue = [];\n            target.forEach(node => {\n                if (!this.nodes.has(node))\n                    return;\n                mergedValue = mergedValue.concat([...node]);\n                nodes.delete(node);\n            });\n            const mergedNode = new Set(mergedValue);\n            nodes.add(mergedNode);\n            const edges = new Set();\n            this.edges.forEach(edge => {\n                const { n0, n1 } = edge;\n                if (target.has(n0) && target.has(n1)) {\n                    return;\n                }\n                else if (target.has(n0)) {\n                    edges.add(new Edge(mergedNode, n1));\n                    return;\n                }\n                else if (target.has(n1)) {\n                    edges.add(new Edge(n0, mergedNode));\n                }\n                else {\n                    edges.add(edge);\n                }\n            });\n            return new DirectedGraph(edges, nodes);\n        }\n    }\n    graph.DirectedGraph = DirectedGraph;\n})(graph = exports.graph || (exports.graph = {}));\n\n},{}],4:[function(require,module,exports){\n\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./board\"));\n__export(require(\"./rule\"));\n__export(require(\"./graph\"));\n__export(require(\"./util\"));\n__export(require(\"./standard\"));\n__export(require(\"./standardMap\"));\n__export(require(\"./standardBoard\"));\n__export(require(\"./standardRule\"));\n\n},{\"./board\":2,\"./graph\":3,\"./rule\":5,\"./standard\":6,\"./standardBoard\":7,\"./standardMap\":8,\"./standardRule\":12,\"./util\":32}],5:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nvar rule;\n(function (rule) {\n    /**\n     * Result of an order execution.\n     */\n    class Executed {\n        /**\n         * @param target The target order.\n         * @param result The result of the target.\n         */\n        constructor(target, result) {\n            this.target = target;\n            this.result = result;\n        }\n    }\n    rule.Executed = Executed;\n    /**\n     * Result of an order execution. It is used when the original order is replaced.\n     */\n    class Replaced {\n        /**\n         * @param target The target order.\n         * @param result The result of the target.\n         * @param invalidReason The reason why the target is replaced\n         * @param replacedBy The order that replaces the target.\n         */\n        constructor(target, invalidReason, replacedBy, result) {\n            this.target = target;\n            this.invalidReason = invalidReason;\n            this.replacedBy = replacedBy;\n            this.result = result;\n        }\n    }\n    rule.Replaced = Replaced;\n    class ResolvedResult {\n        /**\n         * @param board\n         * @param results The set of order results\n         * @param isFinished The flag whether this game is finished or not.\n         */\n        constructor(board, results, isFinished) {\n            this.board = board;\n            this.isFinished = isFinished;\n            this.results = new Set([...results]);\n        }\n    }\n    rule.ResolvedResult = ResolvedResult;\n    /**\n     * Rule of Diplomacy\n     */\n    class Rule {\n        /**\n         * Resolves orders and creates a result.\n         * @param board\n         * @param orders The set of orders to be resolved.\n         * @return The result of the orders\n         */\n        resolve(board, orders) {\n            const os = new Set([...orders]);\n            // Add a default orders if an unit requiring an order has no order\n            for (let unit of [...this.unitsRequiringOrder(board)]) {\n                if ([...orders].every(o => o.unit !== unit)) {\n                    const order = this.defaultOrderOf(board, unit);\n                    if (order) {\n                        os.add(order);\n                    }\n                    else {\n                        throw `${unit}: no order`;\n                    }\n                }\n            }\n            // Replace from invalid orders to default orders\n            const replaced = new Map();\n            os.forEach(order => {\n                const msg = this.errorOfOrder(board, order);\n                if (msg) {\n                    const replacedOrder = this.defaultOrderOf(board, order.unit);\n                    os.delete(order);\n                    if (replacedOrder) {\n                        os.add(replacedOrder);\n                        replaced.set(replacedOrder, [order, msg]);\n                    }\n                    else {\n                        throw `${order.unit}: no order`;\n                    }\n                }\n            });\n            // TODO rename errorOfOrders\n            const msg = this.errorOfOrders(board, os);\n            if (msg) {\n                // Reject if the set of the orders is invalid\n                return new util_1.util.Failure(msg);\n            }\n            const result = this.resolveProcedure(board, os);\n            if (result instanceof util_1.util.Success) {\n                const newResults = result.result.results;\n                replaced.forEach((value, replacedOrder) => {\n                    const [order, message] = value;\n                    const result = [...newResults].find(r => r.target === replacedOrder);\n                    if (result) {\n                        newResults.delete(result);\n                        newResults.add(new Replaced(order, message, result.target, result.result));\n                    }\n                });\n                return new util_1.util.Success(new ResolvedResult(result.result.board, newResults, result.result.isFinished));\n            }\n            return new util_1.util.Failure(result.err);\n        }\n    }\n    rule.Rule = Rule;\n})(rule = exports.rule || (exports.rule = {}));\n\n},{\"./util\":32}],6:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst variant_1 = require(\"./variant\");\nconst standardRule_1 = require(\"./standardRule\");\nconst data_1 = require(\"./standardRule/data\");\nconst standardMap_1 = require(\"./standardMap\");\nconst standardBoard_1 = require(\"./standardBoard\");\nconst power_1 = require(\"./standardMap/power\");\nconst { map, locations: $ } = standardMap_1.standardMap;\nconst { Turn, Season } = standardBoard_1.standardBoard;\nconst { Army, Fleet } = standardRule_1.standardRule.MilitaryBranch;\nconst { Unit, Board, Rule, Phase } = standardRule_1.standardRule;\nconst initialBoard = new Board(map, new data_1.State(new Turn(1901, Season.Spring), Phase.Movement), [\n    new Unit(Army, $.Vie, power_1.Power.Austria), new Unit(Army, $.Bud, power_1.Power.Austria),\n    new Unit(Fleet, $.Tri, power_1.Power.Austria),\n    new Unit(Fleet, $.Edi, power_1.Power.England), new Unit(Fleet, $.Lon, power_1.Power.England),\n    new Unit(Army, $.Lvp, power_1.Power.England),\n    new Unit(Fleet, $.Bre, power_1.Power.France), new Unit(Army, $.Mar, power_1.Power.France),\n    new Unit(Army, $.Par, power_1.Power.France),\n    new Unit(Fleet, $.Kie, power_1.Power.Germany), new Unit(Army, $.Ber, power_1.Power.Germany),\n    new Unit(Army, $.Mun, power_1.Power.Germany),\n    new Unit(Army, $.Ven, power_1.Power.Italy), new Unit(Army, $.Rom, power_1.Power.Italy),\n    new Unit(Fleet, $.Nap, power_1.Power.Italy),\n    new Unit(Fleet, $.Sev, power_1.Power.Russia), new Unit(Army, $.Mos, power_1.Power.Russia),\n    new Unit(Army, $.War, power_1.Power.Russia), new Unit(Fleet, $.StP_SC, power_1.Power.Russia),\n    new Unit(Army, $.Smy, power_1.Power.Turkey), new Unit(Army, $.Con, power_1.Power.Turkey),\n    new Unit(Fleet, $.Ank, power_1.Power.Turkey)\n], [], ([...map.provinces].map(p => {\n    if (p.homeOf !== null) {\n        return [p, new data_1.ProvinceStatus(p.homeOf, false)];\n    }\n    else {\n        return null;\n    }\n}).filter(x => x)));\nconst rule = new Rule();\nvar standard;\n(function (standard) {\n    standard.variant = new variant_1.variant.Variant(rule, initialBoard);\n})(standard = exports.standard || (exports.standard = {}));\n\n},{\"./standardBoard\":7,\"./standardMap\":8,\"./standardMap/power\":11,\"./standardRule\":12,\"./standardRule/data\":16,\"./variant\":33}],7:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar standardBoard;\n(function (standardBoard) {\n    var Season;\n    (function (Season) {\n        Season[Season[\"Spring\"] = 1] = \"Spring\";\n        Season[Season[\"Autumn\"] = 2] = \"Autumn\";\n    })(Season = standardBoard.Season || (standardBoard.Season = {}));\n    /**\n     * The turn of standard Diplomacy rule\n     */\n    class Turn {\n        constructor(year, season) {\n            this.year = year;\n            this.season = season;\n            this.isBuildable = season === Season.Autumn;\n            this.isOccupationUpdateable = season === Season.Autumn;\n        }\n        nextTurn() {\n            if (this.season === Season.Autumn) {\n                return new Turn(this.year + 1, Season.Spring);\n            }\n            else {\n                return new Turn(this.year, Season.Autumn);\n            }\n        }\n    }\n    standardBoard.Turn = Turn;\n})(standardBoard = exports.standardBoard || (exports.standardBoard = {}));\n\n},{}],8:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PowerModule = require(\"./standardMap/power\");\nconst location_1 = require(\"./standardMap/location\");\nconst map_1 = require(\"./standardMap/map\");\nvar standardMap;\n(function (standardMap) {\n    standardMap.Power = PowerModule.Power;\n    standardMap.locations = location_1.locations;\n    standardMap.map = map_1.map;\n})(standardMap = exports.standardMap || (exports.standardMap = {}));\n\n},{\"./standardMap/location\":9,\"./standardMap/map\":10,\"./standardMap/power\":11}],9:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst board_1 = require(\"./../board\");\nconst standardRule_1 = require(\"./../standardRule\");\nconst power_1 = require(\"./power\");\nconst { Name, Province } = board_1.board;\nconst { Army, Fleet } = standardRule_1.standardRule.MilitaryBranch;\nconst { Austria, England, France, Germany, Italy, Russia, Turkey } = power_1.Power;\nconst NC = new Name('North Coast', 'NC');\nconst EC = new Name('East Coast', 'EC');\nconst SC = new Name('South Coast', 'SC');\nconst provinces = {};\nfunction mkLocation(province, militaryBranches) {\n    return new standardRule_1.standardRule.Location(province.name, province, militaryBranches);\n}\nfunction mkLocationWithCoast(province, coast) {\n    return new standardRule_1.standardRule.Location(new Name(`${province.name.name} (${coast.name})`, `${province.name}_${coast}`), province, [Fleet]);\n}\nconst spa = new Province(new Name('Spain', 'Spa'), null, true);\nconst bul = new Province(new Name('Bulgaria', 'Bul'), null, true);\nconst stp = new Province(new Name('St. Petersburg', 'StP'), Russia, true);\nexports.locations = {\n    Boh: mkLocation(new Province(new Name('Bohemia', 'Boh'), Austria), [Army]),\n    Bud: mkLocation(new Province(new Name('Budapest', 'Bud'), Austria, true), [Army]),\n    Gal: mkLocation(new Province(new Name('Galicia', 'Gal'), Austria), [Army]),\n    Tri: mkLocation(new Province(new Name('Trieste', 'Tri'), Austria, true), [Army, Fleet]),\n    Tyr: mkLocation(new Province(new Name('Tyrolia', 'Tyr'), Austria), [Army]),\n    Vie: mkLocation(new Province(new Name('Vienna', 'Vie'), Austria, true), [Army]),\n    Cly: mkLocation(new Province(new Name('Clyde', 'Cly'), England), [Army, Fleet]),\n    Edi: mkLocation(new Province(new Name('Edinburgh', 'Edi'), England, true), [Army, Fleet]),\n    Lvp: mkLocation(new Province(new Name('Liverpool', 'Lvp'), England, true), [Army, Fleet]),\n    Lon: mkLocation(new Province(new Name('London', 'Lon'), England, true), [Army, Fleet]),\n    Wal: mkLocation(new Province(new Name('Wales', 'Wal'), England), [Army, Fleet]),\n    Yor: mkLocation(new Province(new Name('Yorkshire', 'Yor'), England), [Army, Fleet]),\n    Bre: mkLocation(new Province(new Name('Brest', 'Bre'), France, true), [Army, Fleet]),\n    Bur: mkLocation(new Province(new Name('Burgundy', 'Bur'), France), [Army]),\n    Gas: mkLocation(new Province(new Name('Gascony', 'Gas'), France), [Army, Fleet]),\n    Mar: mkLocation(new Province(new Name('Marseilles', 'Mar'), France, true), [Army, Fleet]),\n    Par: mkLocation(new Province(new Name('Paris', 'Par'), France, true), [Army]),\n    Pic: mkLocation(new Province(new Name('Picardy', 'Pic'), France), [Army, Fleet]),\n    Ber: mkLocation(new Province(new Name('Berlin', 'Ber'), Germany, true), [Army, Fleet]),\n    Kie: mkLocation(new Province(new Name('Kiel', 'Kie'), Germany, true), [Army, Fleet]),\n    Mun: mkLocation(new Province(new Name('Munich', 'Mun'), Germany, true), [Army]),\n    Pru: mkLocation(new Province(new Name('Prussia', 'Pru'), Germany), [Army, Fleet]),\n    Ruh: mkLocation(new Province(new Name('Ruhr', 'Ruh'), Germany), [Army]),\n    Sil: mkLocation(new Province(new Name('Silesia', 'Sil'), Germany), [Army]),\n    Apu: mkLocation(new Province(new Name('Apulia', 'Apu'), Italy), [Army, Fleet]),\n    Nap: mkLocation(new Province(new Name('Naples', 'Nap'), Italy, true), [Army, Fleet]),\n    Pie: mkLocation(new Province(new Name('Piedmont', 'Pie'), Italy), [Army, Fleet]),\n    Rom: mkLocation(new Province(new Name('Rome', 'Rom'), Italy, true), [Army, Fleet]),\n    Tus: mkLocation(new Province(new Name('Tuscany', 'Tus'), Italy), [Army, Fleet]),\n    Ven: mkLocation(new Province(new Name('Venice', 'Ven'), Italy, true), [Army, Fleet]),\n    Fin: mkLocation(new Province(new Name('Finland', 'Fin'), Russia), [Army, Fleet]),\n    Lvn: mkLocation(new Province(new Name('Livonia', 'Lvn'), Russia), [Army, Fleet]),\n    Mos: mkLocation(new Province(new Name('Moscow', 'Mos'), Russia, true), [Army]),\n    Sev: mkLocation(new Province(new Name('Sevastopol', 'Sev'), Russia, true), [Army, Fleet]),\n    StP: mkLocation(stp, [Army]),\n    StP_NC: mkLocationWithCoast(stp, NC),\n    StP_SC: mkLocationWithCoast(stp, SC),\n    Ukr: mkLocation(new Province(new Name('Ukraine', 'Ukr'), Russia), [Army]),\n    War: mkLocation(new Province(new Name('Warsaw', 'War'), Russia, true), [Army]),\n    Ank: mkLocation(new Province(new Name('Ankara', 'Ank'), Turkey, true), [Army, Fleet]),\n    Arm: mkLocation(new Province(new Name('Armenia', 'Arm'), Turkey), [Army, Fleet]),\n    Con: mkLocation(new Province(new Name('Constantinople', 'Con'), Turkey, true), [Army, Fleet]),\n    Smy: mkLocation(new Province(new Name('Smyrna', 'Smy'), Turkey, true), [Army, Fleet]),\n    Syr: mkLocation(new Province(new Name('Syria', 'Syr'), Turkey), [Army, Fleet]),\n    Alb: mkLocation(new Province(new Name('Albania', 'Alb'), null), [Army, Fleet]),\n    Bel: mkLocation(new Province(new Name('Belgium', 'Bel'), null, true), [Army, Fleet]),\n    Bul: mkLocation(bul, [Army]),\n    Bul_EC: mkLocationWithCoast(bul, EC),\n    Bul_SC: mkLocationWithCoast(bul, SC),\n    Den: mkLocation(new Province(new Name('Denmark', 'Den'), null, true), [Army, Fleet]),\n    Gre: mkLocation(new Province(new Name('Greece', 'Gre'), null, true), [Army, Fleet]),\n    Hol: mkLocation(new Province(new Name('Holland', 'Hol'), null, true), [Army, Fleet]),\n    Nwy: mkLocation(new Province(new Name('Norway', 'Nwy'), null, true), [Army, Fleet]),\n    Por: mkLocation(new Province(new Name('Portugal', 'Por'), null, true), [Army, Fleet]),\n    Rum: mkLocation(new Province(new Name('Rumania', 'Rum'), null, true), [Army, Fleet]),\n    Ser: mkLocation(new Province(new Name('Serbia', 'Ser'), null, true), [Army]),\n    Spa: mkLocation(spa, [Army]),\n    Spa_SC: mkLocationWithCoast(spa, SC),\n    Spa_NC: mkLocationWithCoast(spa, NC),\n    Swe: mkLocation(new Province(new Name('Sweden', 'Swe'), null, true), [Army, Fleet]),\n    Tun: mkLocation(new Province(new Name('Tunis', 'Tun'), null, true), [Army, Fleet]),\n    NAf: mkLocation(new Province(new Name('North Africa', 'NAf'), null), [Army, Fleet]),\n    Adr: mkLocation(new Province(new Name('Adriatic Sea', 'Adr'), null), [Fleet]),\n    Aeg: mkLocation(new Province(new Name('Aegean Sea', 'Aeg'), null), [Fleet]),\n    Bal: mkLocation(new Province(new Name('Baltic Sea', 'Bal'), null), [Fleet]),\n    Bar: mkLocation(new Province(new Name('Barents Sea', 'Bar'), null), [Fleet]),\n    Bla: mkLocation(new Province(new Name('Black Sea', 'Bla'), null), [Fleet]),\n    Eas: mkLocation(new Province(new Name('Eastern Mediterranean', 'Eas'), null), [Fleet]),\n    Eng: mkLocation(new Province(new Name('English Channel', 'Eng'), null), [Fleet]),\n    Bot: mkLocation(new Province(new Name('Gulf of Bothnia', 'Bot'), null), [Fleet]),\n    GoL: mkLocation(new Province(new Name('Gulf of Lyon', 'GoL'), null), [Fleet]),\n    Hel: mkLocation(new Province(new Name('Helgoland Bight', 'Hel'), null), [Fleet]),\n    Ion: mkLocation(new Province(new Name('Ionian Sea', 'Ion'), null), [Fleet]),\n    Iri: mkLocation(new Province(new Name('Irish Sea', 'Iri'), null), [Fleet]),\n    Mid: mkLocation(new Province(new Name('Mid-Atlantic Ocean', 'Mid'), null), [Fleet]),\n    NAt: mkLocation(new Province(new Name('North Atlantic Ocean', 'NAt'), null), [Fleet]),\n    Nth: mkLocation(new Province(new Name('North Sea', 'Nth'), null), [Fleet]),\n    Nrg: mkLocation(new Province(new Name('Norwegian Sea', 'Nrg'), null), [Fleet]),\n    Ska: mkLocation(new Province(new Name('Skagerrak', 'Ska'), null), [Fleet]),\n    Tyn: mkLocation(new Province(new Name('Tyrrhenian Sea', 'Tyn'), null), [Fleet]),\n    Wes: mkLocation(new Province(new Name('Western Mediterranean', 'Wes'), null), [Fleet])\n};\n\n},{\"./../board\":2,\"./../standardRule\":12,\"./power\":11}],10:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst location_1 = require(\"./location\");\nconst board_1 = require(\"./../board\");\nconst graph_1 = require(\"./../graph\");\nconst standardRule_1 = require(\"./../standardRule\");\nconst { DiplomacyMap, MapEdge } = board_1.board;\nconst { LabeledUndirectedGraph } = graph_1.graph;\nconst { Army, Fleet } = standardRule_1.standardRule.MilitaryBranch;\nexports.map = new DiplomacyMap(new LabeledUndirectedGraph([\n    // Boh\n    new MapEdge(location_1.locations.Boh, location_1.locations.Mun, [Army]),\n    new MapEdge(location_1.locations.Boh, location_1.locations.Sil, [Army]),\n    new MapEdge(location_1.locations.Boh, location_1.locations.Gal, [Army]),\n    new MapEdge(location_1.locations.Boh, location_1.locations.Vie, [Army]),\n    new MapEdge(location_1.locations.Boh, location_1.locations.Tyr, [Army]),\n    // Bud\n    new MapEdge(location_1.locations.Bud, location_1.locations.Vie, [Army]),\n    new MapEdge(location_1.locations.Bud, location_1.locations.Gal, [Army]),\n    new MapEdge(location_1.locations.Bud, location_1.locations.Rum, [Army]),\n    new MapEdge(location_1.locations.Bud, location_1.locations.Ser, [Army]),\n    new MapEdge(location_1.locations.Bud, location_1.locations.Tri, [Army]),\n    // Gal\n    new MapEdge(location_1.locations.Gal, location_1.locations.War, [Army]),\n    new MapEdge(location_1.locations.Gal, location_1.locations.Ukr, [Army]),\n    new MapEdge(location_1.locations.Gal, location_1.locations.Rum, [Army]),\n    new MapEdge(location_1.locations.Gal, location_1.locations.Vie, [Army]),\n    // Tri\n    new MapEdge(location_1.locations.Tri, location_1.locations.Tyr, [Army]),\n    new MapEdge(location_1.locations.Tri, location_1.locations.Vie, [Army]),\n    new MapEdge(location_1.locations.Tri, location_1.locations.Ser, [Army]),\n    new MapEdge(location_1.locations.Tri, location_1.locations.Alb, [Army, Fleet]),\n    new MapEdge(location_1.locations.Tri, location_1.locations.Adr, [Fleet]),\n    new MapEdge(location_1.locations.Tri, location_1.locations.Ven, [Army, Fleet]),\n    // Tyr\n    new MapEdge(location_1.locations.Tyr, location_1.locations.Mun, [Army]),\n    new MapEdge(location_1.locations.Tyr, location_1.locations.Vie, [Army]),\n    new MapEdge(location_1.locations.Tyr, location_1.locations.Ven, [Army]),\n    new MapEdge(location_1.locations.Tyr, location_1.locations.Pie, [Army]),\n    // Vie\n    // Cly\n    new MapEdge(location_1.locations.Cly, location_1.locations.NAt, [Fleet]),\n    new MapEdge(location_1.locations.Cly, location_1.locations.Nrg, [Fleet]),\n    new MapEdge(location_1.locations.Cly, location_1.locations.Edi, [Army, Fleet]),\n    new MapEdge(location_1.locations.Cly, location_1.locations.Lvp, [Army, Fleet]),\n    // Edi\n    new MapEdge(location_1.locations.Edi, location_1.locations.Nrg, [Fleet]),\n    new MapEdge(location_1.locations.Edi, location_1.locations.Nth, [Fleet]),\n    new MapEdge(location_1.locations.Edi, location_1.locations.Yor, [Army, Fleet]),\n    new MapEdge(location_1.locations.Edi, location_1.locations.Lvp, [Army]),\n    // Lvp\n    new MapEdge(location_1.locations.Lvp, location_1.locations.Iri, [Fleet]),\n    new MapEdge(location_1.locations.Lvp, location_1.locations.Yor, [Army]),\n    new MapEdge(location_1.locations.Lvp, location_1.locations.Wal, [Army, Fleet]),\n    new MapEdge(location_1.locations.Lvp, location_1.locations.NAt, [Fleet]),\n    // Lon\n    new MapEdge(location_1.locations.Lon, location_1.locations.Wal, [Army, Fleet]),\n    new MapEdge(location_1.locations.Lon, location_1.locations.Yor, [Army, Fleet]),\n    new MapEdge(location_1.locations.Lon, location_1.locations.Nth, [Fleet]),\n    new MapEdge(location_1.locations.Lon, location_1.locations.Eng, [Fleet]),\n    // Wal\n    new MapEdge(location_1.locations.Wal, location_1.locations.Iri, [Fleet]),\n    new MapEdge(location_1.locations.Wal, location_1.locations.Yor, [Army]),\n    new MapEdge(location_1.locations.Wal, location_1.locations.Eng, [Fleet]),\n    // Yor\n    new MapEdge(location_1.locations.Yor, location_1.locations.Nth, [Fleet]),\n    // Bre\n    new MapEdge(location_1.locations.Bre, location_1.locations.Eng, [Fleet]),\n    new MapEdge(location_1.locations.Bre, location_1.locations.Pic, [Army, Fleet]),\n    new MapEdge(location_1.locations.Bre, location_1.locations.Par, [Army]),\n    new MapEdge(location_1.locations.Bre, location_1.locations.Gas, [Army, Fleet]),\n    new MapEdge(location_1.locations.Bre, location_1.locations.Mid, [Fleet]),\n    // Bur\n    new MapEdge(location_1.locations.Bur, location_1.locations.Par, [Army]),\n    new MapEdge(location_1.locations.Bur, location_1.locations.Pic, [Army]),\n    new MapEdge(location_1.locations.Bur, location_1.locations.Bel, [Army]),\n    new MapEdge(location_1.locations.Bur, location_1.locations.Ruh, [Army]),\n    new MapEdge(location_1.locations.Bur, location_1.locations.Mun, [Army]),\n    new MapEdge(location_1.locations.Bur, location_1.locations.Mar, [Army]),\n    new MapEdge(location_1.locations.Bur, location_1.locations.Gas, [Army]),\n    // Gas\n    new MapEdge(location_1.locations.Gas, location_1.locations.Mid, [Fleet]),\n    new MapEdge(location_1.locations.Gas, location_1.locations.Par, [Army]),\n    new MapEdge(location_1.locations.Gas, location_1.locations.Mar, [Army]),\n    new MapEdge(location_1.locations.Gas, location_1.locations.Spa, [Army]),\n    new MapEdge(location_1.locations.Gas, location_1.locations.Spa_NC, [Fleet]),\n    // Mar\n    new MapEdge(location_1.locations.Mar, location_1.locations.Spa, [Army]),\n    new MapEdge(location_1.locations.Mar, location_1.locations.Spa_SC, [Fleet]),\n    new MapEdge(location_1.locations.Mar, location_1.locations.GoL, [Fleet]),\n    new MapEdge(location_1.locations.Mar, location_1.locations.Pie, [Army, Fleet]),\n    // Par\n    new MapEdge(location_1.locations.Par, location_1.locations.Pic, [Army]),\n    // Pic\n    new MapEdge(location_1.locations.Pic, location_1.locations.Eng, [Fleet]),\n    new MapEdge(location_1.locations.Pic, location_1.locations.Bel, [Army, Fleet]),\n    // Ber\n    new MapEdge(location_1.locations.Ber, location_1.locations.Kie, [Army, Fleet]),\n    new MapEdge(location_1.locations.Ber, location_1.locations.Bal, [Fleet]),\n    new MapEdge(location_1.locations.Ber, location_1.locations.Pru, [Army, Fleet]),\n    new MapEdge(location_1.locations.Ber, location_1.locations.Sil, [Army]),\n    new MapEdge(location_1.locations.Ber, location_1.locations.Mun, [Army]),\n    // Kie\n    new MapEdge(location_1.locations.Kie, location_1.locations.Hel, [Fleet]),\n    new MapEdge(location_1.locations.Kie, location_1.locations.Den, [Army, Fleet]),\n    new MapEdge(location_1.locations.Kie, location_1.locations.Mun, [Army]),\n    new MapEdge(location_1.locations.Kie, location_1.locations.Ruh, [Army]),\n    new MapEdge(location_1.locations.Kie, location_1.locations.Hol, [Army, Fleet]),\n    // Mun\n    new MapEdge(location_1.locations.Mun, location_1.locations.Ruh, [Army]),\n    new MapEdge(location_1.locations.Mun, location_1.locations.Sil, [Army]),\n    // Pru\n    new MapEdge(location_1.locations.Pru, location_1.locations.Bal, [Fleet]),\n    new MapEdge(location_1.locations.Pru, location_1.locations.Lvn, [Army, Fleet]),\n    new MapEdge(location_1.locations.Pru, location_1.locations.War, [Army]),\n    new MapEdge(location_1.locations.Pru, location_1.locations.Sil, [Army]),\n    // Ruh\n    new MapEdge(location_1.locations.Ruh, location_1.locations.Bel, [Army]),\n    new MapEdge(location_1.locations.Ruh, location_1.locations.Hol, [Army]),\n    // Sil\n    new MapEdge(location_1.locations.Sil, location_1.locations.War, [Army]),\n    // Apu\n    new MapEdge(location_1.locations.Apu, location_1.locations.Ven, [Army, Fleet]),\n    new MapEdge(location_1.locations.Apu, location_1.locations.Adr, [Fleet]),\n    new MapEdge(location_1.locations.Apu, location_1.locations.Ion, [Fleet]),\n    new MapEdge(location_1.locations.Apu, location_1.locations.Nap, [Army, Fleet]),\n    new MapEdge(location_1.locations.Apu, location_1.locations.Rom, [Army]),\n    // Nap\n    new MapEdge(location_1.locations.Nap, location_1.locations.Rom, [Army, Fleet]),\n    new MapEdge(location_1.locations.Nap, location_1.locations.Ion, [Fleet]),\n    new MapEdge(location_1.locations.Nap, location_1.locations.Tyn, [Fleet]),\n    // Pie\n    new MapEdge(location_1.locations.Pie, location_1.locations.Ven, [Army]),\n    new MapEdge(location_1.locations.Pie, location_1.locations.Tus, [Army, Fleet]),\n    new MapEdge(location_1.locations.Pie, location_1.locations.GoL, [Fleet]),\n    // Rom\n    new MapEdge(location_1.locations.Rom, location_1.locations.Tus, [Army, Fleet]),\n    new MapEdge(location_1.locations.Rom, location_1.locations.Ven, [Army]),\n    new MapEdge(location_1.locations.Rom, location_1.locations.Tyn, [Fleet]),\n    // Tus\n    new MapEdge(location_1.locations.Tus, location_1.locations.GoL, [Fleet]),\n    new MapEdge(location_1.locations.Tus, location_1.locations.Ven, [Army]),\n    new MapEdge(location_1.locations.Tus, location_1.locations.Tyn, [Fleet]),\n    // Ven\n    new MapEdge(location_1.locations.Ven, location_1.locations.Adr, [Fleet]),\n    // Fin\n    new MapEdge(location_1.locations.Fin, location_1.locations.Nwy, [Army]),\n    new MapEdge(location_1.locations.Fin, location_1.locations.Swe, [Army, Fleet]),\n    new MapEdge(location_1.locations.Fin, location_1.locations.Bot, [Fleet]),\n    new MapEdge(location_1.locations.Fin, location_1.locations.StP, [Army]),\n    new MapEdge(location_1.locations.Fin, location_1.locations.StP_SC, [Fleet]),\n    // Lvn\n    new MapEdge(location_1.locations.Lvn, location_1.locations.Bot, [Fleet]),\n    new MapEdge(location_1.locations.Lvn, location_1.locations.StP, [Army]),\n    new MapEdge(location_1.locations.Lvn, location_1.locations.StP_SC, [Fleet]),\n    new MapEdge(location_1.locations.Lvn, location_1.locations.Mos, [Army]),\n    new MapEdge(location_1.locations.Lvn, location_1.locations.War, [Army]),\n    new MapEdge(location_1.locations.Lvn, location_1.locations.Bal, [Fleet]),\n    // Mos\n    new MapEdge(location_1.locations.Mos, location_1.locations.StP, [Army]),\n    new MapEdge(location_1.locations.Mos, location_1.locations.Sev, [Army]),\n    new MapEdge(location_1.locations.Mos, location_1.locations.Ukr, [Army]),\n    new MapEdge(location_1.locations.Mos, location_1.locations.War, [Army]),\n    // Sev\n    new MapEdge(location_1.locations.Sev, location_1.locations.Ukr, [Army]),\n    new MapEdge(location_1.locations.Sev, location_1.locations.Arm, [Army, Fleet]),\n    new MapEdge(location_1.locations.Sev, location_1.locations.Bla, [Fleet]),\n    new MapEdge(location_1.locations.Sev, location_1.locations.Rum, [Army, Fleet]),\n    // StP\n    new MapEdge(location_1.locations.StP, location_1.locations.Nwy, [Army]),\n    // StP/NC\n    new MapEdge(location_1.locations.StP_NC, location_1.locations.Nwy, [Fleet]),\n    new MapEdge(location_1.locations.StP_NC, location_1.locations.Bar, [Fleet]),\n    // StP/SC\n    new MapEdge(location_1.locations.StP_SC, location_1.locations.Bot, [Fleet]),\n    // Ukr\n    new MapEdge(location_1.locations.Ukr, location_1.locations.War, [Army]),\n    new MapEdge(location_1.locations.Ukr, location_1.locations.Rum, [Army]),\n    // War\n    // Ank\n    new MapEdge(location_1.locations.Ank, location_1.locations.Bla, [Fleet]),\n    new MapEdge(location_1.locations.Ank, location_1.locations.Arm, [Army, Fleet]),\n    new MapEdge(location_1.locations.Ank, location_1.locations.Smy, [Army]),\n    new MapEdge(location_1.locations.Ank, location_1.locations.Con, [Army, Fleet]),\n    // Arm\n    new MapEdge(location_1.locations.Arm, location_1.locations.Bla, [Fleet]),\n    new MapEdge(location_1.locations.Arm, location_1.locations.Syr, [Army]),\n    new MapEdge(location_1.locations.Arm, location_1.locations.Smy, [Army]),\n    // Con\n    new MapEdge(location_1.locations.Con, location_1.locations.Bul, [Army]),\n    new MapEdge(location_1.locations.Con, location_1.locations.Bul_EC, [Fleet]),\n    new MapEdge(location_1.locations.Con, location_1.locations.Bul_SC, [Fleet]),\n    new MapEdge(location_1.locations.Con, location_1.locations.Bla, [Fleet]),\n    new MapEdge(location_1.locations.Con, location_1.locations.Smy, [Army, Fleet]),\n    new MapEdge(location_1.locations.Con, location_1.locations.Aeg, [Fleet]),\n    // Smy\n    new MapEdge(location_1.locations.Smy, location_1.locations.Syr, [Army, Fleet]),\n    new MapEdge(location_1.locations.Smy, location_1.locations.Eas, [Fleet]),\n    new MapEdge(location_1.locations.Smy, location_1.locations.Aeg, [Fleet]),\n    // Syr\n    new MapEdge(location_1.locations.Syr, location_1.locations.Eas, [Fleet]),\n    // Alb\n    new MapEdge(location_1.locations.Alb, location_1.locations.Ser, [Army]),\n    new MapEdge(location_1.locations.Alb, location_1.locations.Gre, [Army, Fleet]),\n    new MapEdge(location_1.locations.Alb, location_1.locations.Ion, [Fleet]),\n    // Bel\n    new MapEdge(location_1.locations.Bel, location_1.locations.Eng, [Fleet]),\n    new MapEdge(location_1.locations.Bel, location_1.locations.Nth, [Fleet]),\n    new MapEdge(location_1.locations.Bel, location_1.locations.Hol, [Army, Fleet]),\n    // Bul\n    new MapEdge(location_1.locations.Bul, location_1.locations.Ser, [Army]),\n    new MapEdge(location_1.locations.Bul, location_1.locations.Rum, [Army]),\n    new MapEdge(location_1.locations.Bul, location_1.locations.Gre, [Army]),\n    // Bul/EC\n    new MapEdge(location_1.locations.Bul_EC, location_1.locations.Rum, [Fleet]),\n    new MapEdge(location_1.locations.Bul_EC, location_1.locations.Bla, [Fleet]),\n    // Bul/SC\n    new MapEdge(location_1.locations.Bul_SC, location_1.locations.Gre, [Fleet]),\n    new MapEdge(location_1.locations.Bul_SC, location_1.locations.Aeg, [Fleet]),\n    // Den\n    new MapEdge(location_1.locations.Den, location_1.locations.Nth, [Fleet]),\n    new MapEdge(location_1.locations.Den, location_1.locations.Ska, [Fleet]),\n    new MapEdge(location_1.locations.Den, location_1.locations.Bal, [Fleet]),\n    new MapEdge(location_1.locations.Den, location_1.locations.Hel, [Fleet]),\n    // Gre\n    new MapEdge(location_1.locations.Gre, location_1.locations.Ser, [Army]),\n    new MapEdge(location_1.locations.Gre, location_1.locations.Aeg, [Fleet]),\n    new MapEdge(location_1.locations.Gre, location_1.locations.Ion, [Fleet]),\n    // Hol\n    new MapEdge(location_1.locations.Hol, location_1.locations.Nth, [Fleet]),\n    new MapEdge(location_1.locations.Hol, location_1.locations.Hel, [Fleet]),\n    // Nwy\n    new MapEdge(location_1.locations.Nwy, location_1.locations.Nrg, [Fleet]),\n    new MapEdge(location_1.locations.Nwy, location_1.locations.Bar, [Fleet]),\n    new MapEdge(location_1.locations.Nwy, location_1.locations.Swe, [Army, Fleet]),\n    new MapEdge(location_1.locations.Nwy, location_1.locations.Ska, [Fleet]),\n    new MapEdge(location_1.locations.Nwy, location_1.locations.Nth, [Fleet]),\n    // Por\n    new MapEdge(location_1.locations.Por, location_1.locations.Mid, [Fleet]),\n    new MapEdge(location_1.locations.Por, location_1.locations.Spa, [Army]),\n    new MapEdge(location_1.locations.Por, location_1.locations.Spa_NC, [Fleet]),\n    new MapEdge(location_1.locations.Por, location_1.locations.Spa_SC, [Fleet]),\n    // Rum\n    new MapEdge(location_1.locations.Rum, location_1.locations.Ser, [Army]),\n    new MapEdge(location_1.locations.Rum, location_1.locations.Bla, [Fleet]),\n    // Ser\n    // Spa\n    // Spa/NC\n    new MapEdge(location_1.locations.Spa_NC, location_1.locations.Mid, [Fleet]),\n    // Spa/SC\n    new MapEdge(location_1.locations.Spa_SC, location_1.locations.Mid, [Fleet]),\n    new MapEdge(location_1.locations.Spa_SC, location_1.locations.GoL, [Fleet]),\n    new MapEdge(location_1.locations.Spa_SC, location_1.locations.Wes, [Fleet]),\n    // Swe\n    new MapEdge(location_1.locations.Swe, location_1.locations.Ska, [Fleet]),\n    new MapEdge(location_1.locations.Swe, location_1.locations.Bal, [Fleet]),\n    new MapEdge(location_1.locations.Swe, location_1.locations.Bot, [Fleet]),\n    new MapEdge(location_1.locations.Swe, location_1.locations.Den, [Army, Fleet]),\n    // Tun\n    new MapEdge(location_1.locations.Tun, location_1.locations.Wes, [Fleet]),\n    new MapEdge(location_1.locations.Tun, location_1.locations.Tyn, [Fleet]),\n    new MapEdge(location_1.locations.Tun, location_1.locations.Ion, [Fleet]),\n    new MapEdge(location_1.locations.Tun, location_1.locations.NAf, [Army, Fleet]),\n    // NAf\n    new MapEdge(location_1.locations.NAf, location_1.locations.Wes, [Fleet]),\n    new MapEdge(location_1.locations.NAf, location_1.locations.Mid, [Fleet]),\n    // Adr\n    new MapEdge(location_1.locations.Adr, location_1.locations.Ion, [Fleet]),\n    // Aeg\n    new MapEdge(location_1.locations.Aeg, location_1.locations.Eas, [Fleet]),\n    new MapEdge(location_1.locations.Aeg, location_1.locations.Ion, [Fleet]),\n    // Bal\n    new MapEdge(location_1.locations.Bal, location_1.locations.Bot, [Fleet]),\n    // Bar\n    new MapEdge(location_1.locations.Bar, location_1.locations.Nrg, [Fleet]),\n    // Bla\n    // Eas\n    new MapEdge(location_1.locations.Eas, location_1.locations.Ion, [Fleet]),\n    // Eng\n    new MapEdge(location_1.locations.Eng, location_1.locations.Iri, [Fleet]),\n    new MapEdge(location_1.locations.Eng, location_1.locations.Nth, [Fleet]),\n    new MapEdge(location_1.locations.Eng, location_1.locations.Mid, [Fleet]),\n    // Bot\n    // GoL\n    new MapEdge(location_1.locations.GoL, location_1.locations.Tyn, [Fleet]),\n    new MapEdge(location_1.locations.GoL, location_1.locations.Wes, [Fleet]),\n    // Hel\n    new MapEdge(location_1.locations.Hel, location_1.locations.Nth, [Fleet]),\n    // Ion\n    new MapEdge(location_1.locations.Ion, location_1.locations.Tyn, [Fleet]),\n    // Iri\n    new MapEdge(location_1.locations.Iri, location_1.locations.NAt, [Fleet]),\n    new MapEdge(location_1.locations.Iri, location_1.locations.Mid, [Fleet]),\n    // Mid\n    new MapEdge(location_1.locations.Mid, location_1.locations.NAf, [Fleet]),\n    new MapEdge(location_1.locations.Mid, location_1.locations.Wes, [Fleet]),\n    new MapEdge(location_1.locations.Mid, location_1.locations.NAt, [Fleet]),\n    // NAt\n    new MapEdge(location_1.locations.NAt, location_1.locations.Nrg, [Fleet]),\n    // Nth\n    new MapEdge(location_1.locations.Nth, location_1.locations.Nrg, [Fleet]),\n    // Nrg\n    // Ska\n    // Tyn\n    new MapEdge(location_1.locations.Tyn, location_1.locations.Wes, [Fleet])\n    // Wes\n]));\n\n},{\"./../board\":2,\"./../graph\":3,\"./../standardRule\":12,\"./location\":9}],11:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Power;\n(function (Power) {\n    Power[Power[\"Austria\"] = 1] = \"Austria\";\n    Power[Power[\"England\"] = 2] = \"England\";\n    Power[Power[\"France\"] = 3] = \"France\";\n    Power[Power[\"Germany\"] = 4] = \"Germany\";\n    Power[Power[\"Italy\"] = 5] = \"Italy\";\n    Power[Power[\"Russia\"] = 6] = \"Russia\";\n    Power[Power[\"Turkey\"] = 7] = \"Turkey\";\n})(Power = exports.Power || (exports.Power = {}));\n\n},{}],12:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Data = require(\"./standardRule/data\");\nconst OrderModule = require(\"./standardRule/order\");\nconst ErrorModule = require(\"./standardRule/error\");\nconst Types = require(\"./standardRule/types\");\nconst UtilsModule = require(\"./standardRule/utils\");\nconst HelperModule = require(\"./standardRule/helper\");\nconst RuleModule = require(\"./standardRule/rule\");\nvar standardRule;\n(function (standardRule) {\n    standardRule.Location = Types.Location;\n    standardRule.Unit = Types.Unit;\n    standardRule.DiplomacyMap = Types.DiplomacyMap;\n    standardRule.Board = Types.Board;\n    standardRule.MilitaryBranch = Data.MilitaryBranch;\n    standardRule.Phase = Data.Phase;\n    standardRule.State = Data.State;\n    standardRule.Dislodged = Data.Dislodged;\n    standardRule.ProvinceStatus = Data.ProvinceStatus;\n    standardRule.Result = Data.Result;\n    var Order;\n    (function (Order_1) {\n        Order_1.OrderType = OrderModule.OrderType;\n        Order_1.Order = OrderModule.Order;\n        Order_1.Hold = OrderModule.Hold;\n        Order_1.Move = OrderModule.Move;\n        Order_1.Support = OrderModule.Support;\n        Order_1.Convoy = OrderModule.Convoy;\n        Order_1.Retreat = OrderModule.Retreat;\n        Order_1.Disband = OrderModule.Disband;\n        Order_1.Build = OrderModule.Build;\n    })(Order = standardRule.Order || (standardRule.Order = {}));\n    var Error;\n    (function (Error_1) {\n        Error_1.Error = ErrorModule.Error;\n        Error_1.PowerWithProblem = ErrorModule.PowerWithProblem;\n        Error_1.UnmovableLocation = ErrorModule.UnmovableLocation;\n        Error_1.UnsupportableLocation = ErrorModule.UnsupportableLocation;\n        Error_1.UnconvoyableLocation = ErrorModule.UnconvoyableLocation;\n        Error_1.UnbuildableLocation = ErrorModule.UnbuildableLocation;\n        Error_1.UnitNotExisted = ErrorModule.UnitNotExisted;\n        Error_1.CannotBeOrdered = ErrorModule.CannotBeOrdered;\n        Error_1.InvalidPhase = ErrorModule.InvalidPhase;\n        Error_1.SeveralOrders = ErrorModule.SeveralOrders;\n        Error_1.OrderNotExisted = ErrorModule.OrderNotExisted;\n    })(Error = standardRule.Error || (standardRule.Error = {}));\n    standardRule.Utils = UtilsModule.Utils;\n    standardRule.Helper = HelperModule.Helper;\n    standardRule.Rule = RuleModule.Rule;\n})(standardRule = exports.standardRule || (exports.standardRule = {}));\n\n},{\"./standardRule/data\":16,\"./standardRule/error\":17,\"./standardRule/helper\":18,\"./standardRule/order\":25,\"./standardRule/rule\":29,\"./standardRule/types\":30,\"./standardRule/utils\":31}],13:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst order_1 = require(\"./order\");\nclass BuildOrderGenerator {\n    ordersToSkipPhase(board) {\n        const numberOfSupplyCenters = utils_1.Utils.numberOfSupplyCenters(board);\n        const canSkip = [...board.map.powers].every(power => {\n            const numOfUnits = ([...board.units].filter(unit => unit.power === power)).length;\n            const numOfSupply = numberOfSupplyCenters.get(power) || 0;\n            return (numOfUnits === numOfSupply) || (numOfSupply === 0);\n        });\n        if (canSkip) {\n            const orders = new Set();\n            board.map.powers.forEach(power => {\n                const units = [...board.units].filter(unit => unit.power === power);\n                const numOfSupply = numberOfSupplyCenters.get(power) || 0;\n                if (numOfSupply === 0) {\n                    units.map(unit => new order_1.Disband(unit)).forEach(o => orders.add(o));\n                }\n            });\n            return orders;\n        }\n        else {\n            return null;\n        }\n    }\n    defaultOrderOf(board, unit) {\n        return null;\n    }\n}\nexports.BuildOrderGenerator = BuildOrderGenerator;\n\n},{\"./order\":25,\"./utils\":31}],14:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst data_1 = require(\"./data\");\nconst types_1 = require(\"./types\");\nconst order_1 = require(\"./order\");\nconst board_1 = require(\"./../board\");\nconst rule_1 = require(\"./../rule\");\nconst util_1 = require(\"./../util\");\nconst { Province } = board_1.board;\nconst { Executed } = rule_1.rule;\nconst { Success } = util_1.util;\nconst Movement = data_1.Phase.Movement;\nclass BuildResolver {\n    resolve(board, orders) {\n        const disbands = [...orders].filter(order => order.tpe === order_1.OrderType.Disband);\n        const builds = [...orders].filter(order => order.tpe === order_1.OrderType.Build);\n        const newUnits = new Set([...board.units]);\n        disbands.forEach(d => newUnits.delete(d.unit));\n        builds.forEach(b => newUnits.add(b.unit));\n        const newState = new data_1.State(board.state.turn.nextTurn(), Movement);\n        const occupationStatuses = [...board.provinceStatuses]\n            .filter(elem => elem[1].occupied)\n            .map(elem => {\n            if (elem[1].standoff) {\n                return [elem[0], new data_1.ProvinceStatus(elem[1].occupied, false)];\n            }\n            else {\n                return elem;\n            }\n        });\n        const newBoard = new types_1.Board(board.map, newState, newUnits, [], occupationStatuses);\n        const orderResults = [...orders].map(order => new Executed(order, data_1.Result.Success));\n        return new Success(new types_1.ResolvedResult(newBoard, orderResults, false));\n    }\n}\nexports.BuildResolver = BuildResolver;\n\n},{\"./../board\":2,\"./../rule\":5,\"./../util\":32,\"./data\":16,\"./order\":25,\"./types\":30}],15:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst order_1 = require(\"./order\");\nconst Error = require(\"./error\");\nclass BuildValidator {\n    /**\n     * @param stringify Stringify instances of Power\n     */\n    constructor() { }\n    unitsRequiringOrder(board) {\n        return new Set();\n    }\n    errorOfOrder(board, order) {\n        const numberOfSupplyCenters = utils_1.Utils.numberOfSupplyCenters(board);\n        switch (order.tpe) {\n            case order_1.OrderType.Build:\n                if ([...board.units].some(unit => unit.location.province === order.unit.location.province)) {\n                    return new Error.UnbuildableLocation(order.unit);\n                }\n                else if (order.unit.location.province.homeOf !== order.unit.power) {\n                    return new Error.UnbuildableLocation(order.unit);\n                }\n                else if (!order.unit.location.province.isSupplyCenter) {\n                    return new Error.UnbuildableLocation(order.unit);\n                }\n                else {\n                    const status = board.provinceStatuses.get(order.unit.location.province);\n                    if (!status || status.occupied !== order.unit.power) {\n                        return new Error.UnbuildableLocation(order.unit);\n                    }\n                }\n                break;\n            case order_1.OrderType.Disband:\n                if (!board.units.has(order.unit)) {\n                    return new Error.UnitNotExisted(order.unit);\n                }\n                const numOfUnits = ([...board.units].filter(unit => unit.power === order.unit.power)).length;\n                const numOfSupply = numberOfSupplyCenters.get(order.unit.power) || 0;\n                if (numOfUnits <= numOfSupply) {\n                    return new Error.PowerWithProblem(order.unit.power);\n                }\n                break;\n            default:\n                return new Error.InvalidPhase(order);\n        }\n        return null;\n    }\n    errorOfOrders(board, orders) {\n        const numberOfSupplyCenters = utils_1.Utils.numberOfSupplyCenters(board);\n        const power = [...board.map.powers].find(power => {\n            const numOfUnits = ([...board.units].filter(unit => unit.power === power)).length;\n            const numOfSupply = numberOfSupplyCenters.get(power) || 0;\n            const diffs = [...orders].map(order => {\n                if (order.tpe === order_1.OrderType.Build && order.unit.power === power) {\n                    return 1;\n                }\n                else if (order.tpe === order_1.OrderType.Disband && order.unit.power === power) {\n                    return -1;\n                }\n                else {\n                    return 0;\n                }\n            });\n            const diff = diffs.reduce((prev, curr) => prev + curr, 0);\n            return (numOfUnits + diff) > numOfSupply;\n        });\n        if (power) {\n            return new Error.PowerWithProblem(power);\n        }\n        return null;\n    }\n}\nexports.BuildValidator = BuildValidator;\n\n},{\"./error\":17,\"./order\":25,\"./utils\":31}],16:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MilitaryBranch;\n(function (MilitaryBranch) {\n    MilitaryBranch[MilitaryBranch[\"Army\"] = 1] = \"Army\";\n    MilitaryBranch[MilitaryBranch[\"Fleet\"] = 2] = \"Fleet\";\n})(MilitaryBranch = exports.MilitaryBranch || (exports.MilitaryBranch = {}));\nvar Phase;\n(function (Phase) {\n    Phase[Phase[\"Movement\"] = 1] = \"Movement\";\n    Phase[Phase[\"Retreat\"] = 2] = \"Retreat\";\n    Phase[Phase[\"Build\"] = 3] = \"Build\";\n})(Phase = exports.Phase || (exports.Phase = {}));\nclass State {\n    constructor(turn, phase) {\n        this.turn = turn;\n        this.phase = phase;\n    }\n}\nexports.State = State;\n/**\n * Status that an unit is dislodged\n */\nclass Dislodged {\n    /**\n     * @param attackedFrom - The province that the unit is attacked from\n     */\n    constructor(attackedFrom) {\n        this.attackedFrom = attackedFrom;\n    }\n}\nexports.Dislodged = Dislodged;\n/**\n * Status of the province\n */\nclass ProvinceStatus {\n    /**\n     * @param occupied\n     *    The power that occupies the province. The province is neutral if this property is null\n     * @param standoff The flag whether standoff is occurred or not\n     */\n    constructor(occupied, standoff) {\n        this.occupied = occupied;\n        this.standoff = standoff;\n    }\n}\nexports.ProvinceStatus = ProvinceStatus;\nvar Result;\n(function (Result) {\n    Result[Result[\"Success\"] = 1] = \"Success\";\n    Result[Result[\"Failed\"] = 2] = \"Failed\";\n    Result[Result[\"Dislodged\"] = 3] = \"Dislodged\";\n    Result[Result[\"Bounced\"] = 4] = \"Bounced\";\n    Result[Result[\"Cut\"] = 5] = \"Cut\";\n    Result[Result[\"Standoff\"] = 6] = \"Standoff\";\n    Result[Result[\"NoCorrespondingOrder\"] = 7] = \"NoCorrespondingOrder\";\n})(Result = exports.Result || (exports.Result = {}));\n\n},{}],17:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Errors while resolving orders\n  * @typeparam Detail The detail of the error\n */\nclass Error {\n}\nexports.Error = Error;\n/**\n * Error that a power does not satisify conditions.\n * (e.g., A power does not have enough number of supply centers.)\n */\nclass PowerWithProblem extends Error {\n    constructor(power) {\n        super();\n        this.power = power;\n    }\n}\nexports.PowerWithProblem = PowerWithProblem;\n/**\n * Error that a unit tries to move an unmovable location.\n */\nclass UnmovableLocation extends Error {\n    constructor(unit, destination) {\n        super();\n        this.unit = unit;\n        this.destination = destination;\n    }\n}\nexports.UnmovableLocation = UnmovableLocation;\n/**\n * Error that a unit tries to suppor an unsupportable order.\n */\nclass UnsupportableLocation extends Error {\n    constructor(unit, destination) {\n        super();\n        this.unit = unit;\n        this.destination = destination;\n    }\n}\nexports.UnsupportableLocation = UnsupportableLocation;\n/**\n * Error that a unit tries to convoy an invalid order.\n */\nclass UnconvoyableLocation extends Error {\n    constructor(unit, destination) {\n        super();\n        this.unit = unit;\n        this.destination = destination;\n    }\n}\nexports.UnconvoyableLocation = UnconvoyableLocation;\n/**\n * Error that a power tries to build an unbuildable location.\n */\nclass UnbuildableLocation extends Error {\n    constructor(unit) {\n        super();\n        this.unit = unit;\n    }\n}\nexports.UnbuildableLocation = UnbuildableLocation;\n/**\n * Error that a unit does not existed.\n */\nclass UnitNotExisted extends Error {\n    constructor(unit) {\n        super();\n        this.unit = unit;\n    }\n}\nexports.UnitNotExisted = UnitNotExisted;\n/**\n * Error that a player writes an invalid order.\n */\nclass CannotBeOrdered extends Error {\n    constructor(order) {\n        super();\n        this.order = order;\n    }\n}\nexports.CannotBeOrdered = CannotBeOrdered;\n/**\n * Error that a player writes an invalid order.\n */\nclass InvalidPhase extends Error {\n    constructor(order) {\n        super();\n        this.order = order;\n    }\n}\nexports.InvalidPhase = InvalidPhase;\nclass SeveralOrders extends Error {\n    constructor(units) {\n        super();\n        this.units = new Set([...units]);\n    }\n}\nexports.SeveralOrders = SeveralOrders;\nclass OrderNotExisted extends Error {\n    constructor(unit) {\n        super();\n        this.unit = unit;\n    }\n}\nexports.OrderNotExisted = OrderNotExisted;\n\n},{}],18:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst board_1 = require(\"./../board\");\nconst types_1 = require(\"./types\");\nconst data_1 = require(\"./data\");\nconst Order = require(\"./order\");\nconst { Province } = board_1.board;\nclass UnitForStandardRule {\n    constructor(unit) {\n        this.unit = unit;\n    }\n    hold() {\n        return new Order.Hold(this.unit);\n    }\n    move(destination) {\n        return new Order.Move(this.unit, destination);\n    }\n    moveViaConvoy(destination) {\n        return new Order.Move(this.unit, destination, true);\n    }\n    support(target) {\n        return new Order.Support(this.unit, target);\n    }\n    convoy(target) {\n        return new Order.Convoy(this.unit, target);\n    }\n    retreat(destination) {\n        return new Order.Retreat(this.unit, destination);\n    }\n    disband() {\n        return new Order.Disband(this.unit);\n    }\n    build() {\n        return new Order.Build(this.unit);\n    }\n}\nexports.UnitForStandardRule = UnitForStandardRule;\n/**\n * Helper for creating orders of the standard rule\n * ```\n * const $$ = new Helper(board)\n * const $ = // The dictionary of the locations\n * $$.U($.Lon).move($.Nth)\n *\n * $$.U($.Mar).support($$.A($.Par).move($.Bur))\n *\n * $$.F($.Lon).build()\n *\n * $$.U($.Nrg).disband()\n * ```\n */\nclass Helper {\n    constructor(board) {\n        this.board = board;\n    }\n    getUnit(militaryBranch, location) {\n        function checkMilitaryBranch(tgt) {\n            if (militaryBranch !== null) {\n                return tgt === militaryBranch;\n            }\n            else {\n                return true;\n            }\n        }\n        if (this.board.state.phase === data_1.Phase.Movement) {\n            const u = [...this.board.units].find(unit => {\n                return (unit.location === location) && checkMilitaryBranch(unit.militaryBranch);\n            });\n            if (u) {\n                return u;\n            }\n            else {\n                throw `Cannot find unit: ${location}`;\n            }\n        }\n        else if (this.board.state.phase === data_1.Phase.Retreat) {\n            const u = [...this.board.units].find(unit => {\n                return (unit.location === location) && checkMilitaryBranch(unit.militaryBranch) && this.board.unitStatuses.has(unit);\n            });\n            if (u) {\n                return u;\n            }\n            else {\n                throw `Cannot find unit: ${location}`;\n            }\n        }\n        else {\n            const unit = [...this.board.units].find(unit => {\n                return (unit.location === location) && checkMilitaryBranch(unit.militaryBranch);\n            });\n            if (!unit) {\n                if ((militaryBranch !== null) && location.province.homeOf) {\n                    return new types_1.Unit(militaryBranch, location, location.province.homeOf);\n                }\n                else {\n                    throw `Cannot find unit: ${location}`;\n                }\n            }\n            else {\n                return unit;\n            }\n        }\n    }\n    A(location) {\n        return new UnitForStandardRule(this.getUnit(data_1.MilitaryBranch.Army, location));\n    }\n    F(location) {\n        return new UnitForStandardRule(this.getUnit(data_1.MilitaryBranch.Fleet, location));\n    }\n    U(location) {\n        return new UnitForStandardRule(this.getUnit(null, location));\n    }\n}\nexports.Helper = Helper;\n\n},{\"./../board\":2,\"./data\":16,\"./order\":25,\"./types\":30}],19:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst order_1 = require(\"./order\");\nclass MovementOrderGenerator {\n    defaultOrderOf(board, unit) {\n        return new order_1.Hold(unit);\n    }\n    ordersToSkipPhase(board) {\n        if (board.units.size === 0) {\n            return new Set();\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.MovementOrderGenerator = MovementOrderGenerator;\n\n},{\"./order\":25}],20:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst data_1 = require(\"./data\");\nconst utils_1 = require(\"./utils\");\nconst order_1 = require(\"./order\");\nconst { Fleet } = data_1.MilitaryBranch;\nclass MovementOrderGroup {\n    constructor(target, relatedOrders) {\n        this.target = target;\n        this.relatedOrders = new Set([...relatedOrders]);\n    }\n    validSupports() {\n        return new Set([...this.relatedOrders].filter(order => {\n            return (order.order.tpe === order_1.OrderType.Support) &&\n                (order.getResult() !== data_1.Result.Dislodged) && (order.getResult() !== data_1.Result.Cut) &&\n                (order.getResult() !== data_1.Result.NoCorrespondingOrder);\n        }).map(order => order.order));\n    }\n    power() {\n        return 1 + this.validSupports().size;\n    }\n    route(map) {\n        if (this.target.order instanceof order_1.Move) {\n            const units = [...this.relatedOrders].filter(order => {\n                return (order.order.tpe === order_1.OrderType.Convoy) &&\n                    ((order.getResult() === data_1.Result.Failed) || (order.getResult() === data_1.Result.Success));\n            }).map(order => order.order.unit);\n            if (utils_1.Utils.isMovableViaSea(map, this.target.order.unit.location.province, this.target.order.destination.province, new Set(units))) {\n                return { viaConvoy: true };\n            }\n            else if (map.movableLocationsOf(this.target.order.unit.location, this.target.order.unit.militaryBranch).has(this.target.order.destination)) {\n                return { viaConvoy: false };\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.MovementOrderGroup = MovementOrderGroup;\n\n},{\"./data\":16,\"./order\":25,\"./utils\":31}],21:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst data_1 = require(\"./data\");\nconst order_1 = require(\"./order\");\nclass MovementOrderWithResult {\n    constructor(order) {\n        this.order = order;\n        this.result = null;\n    }\n    getResult() {\n        return this.result;\n    }\n    setResult(result) {\n        if (this.order instanceof order_1.Hold) {\n            if (result === data_1.Result.Dislodged || result === data_1.Result.Success) {\n                this.result = result;\n            }\n        }\n        else if (this.order instanceof order_1.Move) {\n            if (result === data_1.Result.Dislodged || result === data_1.Result.Success) {\n                if (this.result !== data_1.Result.Success) {\n                    this.result = result;\n                }\n            }\n            else if (result === data_1.Result.Failed || result === data_1.Result.Bounced) {\n                if (this.result !== data_1.Result.Dislodged) {\n                    this.result = result;\n                }\n            }\n        }\n        else if (this.order instanceof order_1.Support) {\n            if (result === data_1.Result.Dislodged) {\n                this.result = result;\n            }\n            else if (result === data_1.Result.Failed || result === data_1.Result.Success) {\n                if ((this.result !== data_1.Result.Dislodged) &&\n                    (this.result !== data_1.Result.Cut) &&\n                    (this.result !== data_1.Result.NoCorrespondingOrder)) {\n                    this.result = result;\n                }\n            }\n            else if (result === data_1.Result.Cut) {\n                if (this.result !== data_1.Result.Dislodged) {\n                    this.result = result;\n                }\n            }\n            else if (result === data_1.Result.NoCorrespondingOrder) {\n                this.result = result;\n            }\n        }\n        else if (this.order instanceof order_1.Convoy) {\n            if (result === data_1.Result.Dislodged) {\n                this.result = result;\n            }\n            else if (result === data_1.Result.Failed || result === data_1.Result.Success) {\n                if (this.result !== data_1.Result.Dislodged && this.result !== data_1.Result.NoCorrespondingOrder) {\n                    this.result = result;\n                }\n            }\n            else if (result === data_1.Result.NoCorrespondingOrder) {\n                this.result = result;\n            }\n        }\n        else {\n            throw { err: `Invalid order: ${this.order}` };\n        }\n    }\n}\nexports.MovementOrderWithResult = MovementOrderWithResult;\n\n},{\"./data\":16,\"./order\":25}],22:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst data_1 = require(\"./data\");\nconst order_1 = require(\"./order\");\nconst types_1 = require(\"./types\");\nconst movement_order_with_result_1 = require(\"./movement-order-with-result\");\nconst movement_order_group_1 = require(\"./movement-order-group\");\nconst order_dependency_1 = require(\"./order-dependency\");\nconst board_1 = require(\"./../board\");\nconst rule_1 = require(\"./../rule\");\nconst util_1 = require(\"./../util\");\nconst { Province } = board_1.board;\nconst { Executed } = rule_1.rule;\nconst { Success } = util_1.util;\nconst { Retreat } = data_1.Phase;\nclass TmpMovementOrderGroup {\n    constructor(target, relatedOrders) {\n        this.target = target;\n        this.relatedOrders = relatedOrders;\n    }\n}\nclass MovementResolver {\n    resolve(board, orders) {\n        const ordersWithResult = [...orders].map(order => new movement_order_with_result_1.MovementOrderWithResult(order));\n        const movesViaConvoy = new Set();\n        const dislodgedFrom = new Map();\n        function canBounce(order1, order2) {\n            const o1 = order1.order;\n            const o2 = order2.order;\n            if (o1 instanceof order_1.Move && o2 instanceof order_1.Move) {\n                if (o1.destination.province === o2.destination.province) {\n                    return true;\n                }\n                else if ((o1.destination.province === o2.unit.location.province) &&\n                    (o2.destination.province === o1.unit.location.province)) {\n                    if (movesViaConvoy.has(order1.order) || movesViaConvoy.has(order2.order)) {\n                        return order1.getResult() === data_1.Result.Bounced || order2.getResult() === data_1.Result.Bounced;\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else if (o1.destination.province === o2.unit.location.province) {\n                    return order2.getResult() === data_1.Result.Bounced;\n                }\n                else if (o2.destination.province === o1.unit.location.province) {\n                    return order1.getResult() === data_1.Result.Bounced;\n                }\n                else {\n                    return false;\n                }\n            }\n            else if (o1 instanceof order_1.Move) {\n                return o1.destination.province === order2.order.unit.location.province;\n            }\n            else if (o2 instanceof order_1.Move) {\n                return o2.destination.province === order1.order.unit.location.province;\n            }\n            else {\n                return false;\n            }\n        }\n        // 1. Divide orders into groups\n        const province2TmpOrderGroup = new Map();\n        function getOrderGroup(province, location) {\n            const groups = province2TmpOrderGroup.get(province) || new Map();\n            const group = groups.get(location) || new TmpMovementOrderGroup(null, new Set());\n            groups.set(location, group);\n            province2TmpOrderGroup.set(province, groups);\n            return group;\n        }\n        ordersWithResult.forEach(order => {\n            const group = getOrderGroup(order.order.unit.location.province, order.order.unit.location);\n            group.target = order;\n            const o = order.order;\n            if (o instanceof order_1.Hold) {\n            }\n            else if (o instanceof order_1.Move) {\n                const o2 = o;\n                const group2 = getOrderGroup(o2.destination.province, o2.unit.location);\n                group2.target = order;\n            }\n            else if (o instanceof order_1.Support) {\n                const o2 = o;\n                const group2 = getOrderGroup(o2.destination.province, o2.target.unit.location);\n                group2.relatedOrders.add(order);\n            }\n            else if (o instanceof order_1.Convoy) {\n                const o2 = o;\n                const group2 = getOrderGroup(o2.target.destination.province, o2.target.unit.location);\n                group2.relatedOrders.add(order);\n            }\n        });\n        // 2. Exclude support or convoy orders that have no corresponding orders\n        for (let elem of [...province2TmpOrderGroup]) {\n            for (let elem2 of [...elem[1]]) {\n                if (elem2[1].target === null) {\n                    elem2[1].relatedOrders.forEach((order) => {\n                        order.setResult(data_1.Result.NoCorrespondingOrder);\n                    });\n                    elem[1].delete(elem2[0]);\n                }\n                else {\n                    elem2[1].relatedOrders.forEach((order) => {\n                        if (order.order instanceof order_1.Support || order.order instanceof order_1.Convoy) {\n                            const targetType1 = order.order.target.tpe;\n                            const targetType2 = elem2[1].target.order.tpe;\n                            switch (targetType2) {\n                                case order_1.OrderType.Move:\n                                    if (targetType1 !== order_1.OrderType.Move) {\n                                        order.setResult(data_1.Result.NoCorrespondingOrder);\n                                    }\n                                    break;\n                                default:\n                                    if (targetType1 !== order_1.OrderType.Hold) {\n                                        order.setResult(data_1.Result.NoCorrespondingOrder);\n                                    }\n                                    break;\n                            }\n                        }\n                    });\n                }\n            }\n        }\n        const province2OrderGroups = new Map();\n        province2TmpOrderGroup.forEach((groups, province) => {\n            const newGroups = [...groups.values()].map(x => {\n                return new movement_order_group_1.MovementOrderGroup(x.target, x.relatedOrders);\n            });\n            province2OrderGroups.set(province, new Set([...newGroups]));\n        });\n        // 3. Generate the dependency graph\n        let graph = new order_dependency_1.OrderDependency(ordersWithResult).graph;\n        // 4. Resolve orders following dependency\n        while (graph.nodes.size > 0) {\n            const target = [...graph.nodes].find(node => graph.incomingNodesOf(node).size === 0);\n            if (!target) {\n                throw \"Internal Error\";\n            }\n            graph = graph.deleteNode(target);\n            const provinces = target;\n            // Get all related order groups\n            const relatedGroups = new Map([...provinces].map((province) => {\n                const groups = province2OrderGroups.get(province) || new Set();\n                return ([province, new Set([...groups])]);\n            }));\n            // Resolve each province\n            while (relatedGroups.size !== 0) {\n                // 1. Resolve cutting support\n                relatedGroups.forEach(groups => {\n                    groups.forEach(group => {\n                        const o = group.target.order;\n                        if (o instanceof order_1.Support) {\n                            const destination = o.destination;\n                            const isCut = [...groups].some(group => {\n                                const o2 = group.target.order;\n                                if (o2 instanceof order_1.Move) {\n                                    return ((group.target.order.unit.location.province !== destination.province) &&\n                                        (group.route(board.map)) &&\n                                        (o.unit.power !== group.target.order.unit.power)) || false;\n                                }\n                                return false;\n                            });\n                            if (isCut) {\n                                group.target.setResult(data_1.Result.Cut);\n                            }\n                        }\n                    });\n                });\n                // 2. Sort provinces by related units\n                const sortedGroups = [...relatedGroups].sort((a, b) => {\n                    const hasG1Convoy = [...a[1]].some(group => {\n                        return group.target.order.tpe === order_1.OrderType.Convoy;\n                    });\n                    const hasG2Convoy = [...b[1]].some(group => {\n                        return group.target.order.tpe === order_1.OrderType.Convoy;\n                    });\n                    if (hasG1Convoy) {\n                        return -1;\n                    }\n                    else if (hasG2Convoy) {\n                        return 1;\n                    }\n                    else {\n                        const pow1 = Math.max(...[...a[1]].map(group => group.power()));\n                        const pow2 = Math.max(...[...b[1]].map(group => group.power()));\n                        return (pow1 > pow2) ? -1 : 1;\n                    }\n                });\n                // 3. Check whether move orders can be conducted or not\n                const failedMoves = new Set();\n                sortedGroups.forEach(elem => {\n                    const [province, groups] = elem;\n                    groups.forEach(group => {\n                        const o = group.target.order;\n                        if ((o instanceof order_1.Move) &&\n                            (province === o.destination.province)) {\n                            const route = group.route(board.map);\n                            if (route) {\n                                if (route.viaConvoy) {\n                                    movesViaConvoy.add(group.target.order);\n                                }\n                            }\n                            else {\n                                failedMoves.add(group);\n                            }\n                        }\n                    });\n                });\n                if (sortedGroups.length === 0) {\n                    continue;\n                }\n                // 4. Resolve the province, and delete it from the buffer\n                const [province, groups] = sortedGroups[0];\n                relatedGroups.delete(province);\n                // 5. Resolve and exclude failed move orders\n                groups.forEach(group => {\n                    if (failedMoves.has(group)) {\n                        group.target.setResult(data_1.Result.Failed);\n                        group.relatedOrders.forEach(o => { o.setResult(data_1.Result.Failed); });\n                        groups.delete(group);\n                    }\n                });\n                const defenceOpt = [...groups].find(group => {\n                    return group.target.order.unit.location.province === province;\n                });\n                const offence = new Set([...groups]);\n                if (defenceOpt)\n                    offence.delete(defenceOpt);\n                // 6. Resolve and exclude dislodged moves if #provinces <= 2\n                if ([...provinces].length <= 2) {\n                    if (defenceOpt) {\n                        offence.forEach(group => {\n                            if (group.target.order.tpe === order_1.OrderType.Move) {\n                                const isDislodged = (!group.target.getResult()) ? false : group.target.getResult() === data_1.Result.Dislodged;\n                                if (isDislodged && canBounce(group.target, defenceOpt.target)) {\n                                    groups.delete(group);\n                                    offence.delete(group);\n                                    group.relatedOrders.forEach(o => { o.setResult(data_1.Result.Failed); });\n                                }\n                            }\n                        });\n                    }\n                }\n                if (groups.size === 0)\n                    continue;\n                // 7. Find orders that have the highest power\n                const maxPower = Math.max(...[...groups].map(group => group.power()));\n                const maxOrders = new Set([...groups].filter(g => g.power() >= maxPower).map(g => g.target));\n                // 8. Resolve the defence order\n                if (defenceOpt) {\n                    if (maxOrders.has(defenceOpt.target)) {\n                        const o = defenceOpt.target.order;\n                        if (o instanceof order_1.Move) {\n                        }\n                        else if (o instanceof order_1.Hold) {\n                            defenceOpt.target.setResult(data_1.Result.Success);\n                            defenceOpt.relatedOrders.forEach(o => { o.setResult(data_1.Result.Success); });\n                        }\n                        else if (o instanceof order_1.Convoy) {\n                            if (defenceOpt.target.getResult() !== data_1.Result.NoCorrespondingOrder) {\n                                defenceOpt.target.setResult(data_1.Result.Failed); // This convoy order is available.\n                            }\n                            defenceOpt.relatedOrders.forEach(o => { o.setResult(data_1.Result.Success); });\n                        }\n                        else {\n                            defenceOpt.relatedOrders.forEach(o => { o.setResult(data_1.Result.Success); });\n                        }\n                    }\n                    else {\n                        let isDislodged = false;\n                        const offenceGroup = [...offence].find(group => maxOrders.has(group.target));\n                        if (maxOrders.size === 1) {\n                            if (offenceGroup) {\n                                let offensivePower = 0;\n                                if (offenceGroup.target.order.unit.power !== defenceOpt.target.order.unit.power) {\n                                    offensivePower += 1;\n                                }\n                                const validSupports = [...offenceGroup.validSupports()].filter(s => {\n                                    return s.unit.power !== defenceOpt.target.order.unit.power;\n                                });\n                                offensivePower += validSupports.length;\n                                isDislodged = defenceOpt.power() < offensivePower;\n                            }\n                            if (isDislodged) {\n                                if (offenceGroup) {\n                                    defenceOpt.target.setResult(data_1.Result.Dislodged);\n                                    dislodgedFrom.set(defenceOpt.target.order.unit, offenceGroup.target.order.unit.location.province);\n                                    defenceOpt.relatedOrders.forEach(order => { order.setResult(data_1.Result.Failed); });\n                                }\n                            }\n                            else {\n                                if (defenceOpt.target.order.tpe === order_1.OrderType.Hold) {\n                                    defenceOpt.target.setResult(data_1.Result.Success);\n                                    defenceOpt.relatedOrders.forEach(o => { o.setResult(data_1.Result.Success); });\n                                }\n                            }\n                        }\n                    }\n                }\n                // 9. Resolve the offence orders\n                offence.forEach(group => {\n                    let isBounced = true;\n                    if (maxOrders.has(group.target)) {\n                        if (maxOrders.size === 1) {\n                            if (defenceOpt) {\n                                if (defenceOpt.target.order.tpe === order_1.OrderType.Move) {\n                                    isBounced = (defenceOpt.target.getResult() !== data_1.Result.Success) &&\n                                        (defenceOpt.target.getResult() !== data_1.Result.Dislodged);\n                                }\n                                else {\n                                    isBounced = defenceOpt.target.getResult() !== data_1.Result.Dislodged;\n                                }\n                            }\n                            else {\n                                isBounced = false;\n                            }\n                        }\n                        else if (maxOrders.size === 2) {\n                            const order2 = ([...maxOrders].find(o => o !== group.target));\n                            isBounced = canBounce(group.target, order2);\n                        }\n                    }\n                    if (isBounced) {\n                        group.target.setResult(data_1.Result.Bounced);\n                        group.relatedOrders.forEach(o => { o.setResult(data_1.Result.Failed); });\n                    }\n                    else {\n                        group.target.setResult(data_1.Result.Success);\n                        group.relatedOrders.forEach(o => { o.setResult(data_1.Result.Success); });\n                    }\n                });\n            }\n        }\n        // Generate a new board\n        const unit2Result = new Map(ordersWithResult.map(order => {\n            return [order.order.unit, [order.order, order.getResult()]];\n        }));\n        const newUnits = new Set();\n        board.units.forEach(unit => {\n            const r = unit2Result.get(unit);\n            if (r) {\n                const [order, result] = r;\n                if (order instanceof order_1.Move && result === data_1.Result.Success) {\n                    newUnits.add(new types_1.Unit(unit.militaryBranch, order.destination, unit.power));\n                }\n                else {\n                    newUnits.add(unit);\n                }\n            }\n            else {\n                newUnits.add(unit);\n            }\n        });\n        const newUnitStatuses = new Map();\n        ordersWithResult.forEach(order => {\n            if (order.getResult() === data_1.Result.Dislodged) {\n                const x = dislodgedFrom.get(order.order.unit);\n                newUnitStatuses.set(order.order.unit, new data_1.Dislodged(x));\n            }\n        });\n        const provincesContainingUnit = new Set([...newUnits].map(u => u.location.province));\n        const occupationStatuses = [...board.provinceStatuses]\n            .filter(elem => elem[1].occupied)\n            .map(elem => {\n            if (elem[1].standoff) {\n                return [elem[0], new data_1.ProvinceStatus(elem[1].occupied, false)];\n            }\n            else {\n                return elem;\n            }\n        });\n        const newProvinceStatuses = new Map([...occupationStatuses]);\n        province2OrderGroups.forEach((groups, province) => {\n            const wasBounced = [...groups].some(group => group.target.getResult() === data_1.Result.Bounced);\n            const standoff = wasBounced && !(provincesContainingUnit.has(province));\n            if (standoff) {\n                const current = newProvinceStatuses.get(province) || new data_1.ProvinceStatus(null, true);\n                const x = new data_1.ProvinceStatus(current.occupied, true);\n                newProvinceStatuses.set(province, x);\n            }\n        });\n        const newState = new data_1.State(board.state.turn, Retreat);\n        const newBoard = new types_1.Board(board.map, newState, newUnits, newUnitStatuses, newProvinceStatuses);\n        const orderResults = [...ordersWithResult].map(order => {\n            const r = order.getResult();\n            if (r !== null) {\n                return new Executed(order.order, r);\n            }\n            else {\n                throw `Internal error: ${order.order} was not resolved`;\n            }\n        });\n        return new Success(new types_1.ResolvedResult(newBoard, orderResults, false));\n    }\n}\nexports.MovementResolver = MovementResolver;\n\n},{\"./../board\":2,\"./../rule\":5,\"./../util\":32,\"./data\":16,\"./movement-order-group\":20,\"./movement-order-with-result\":21,\"./order\":25,\"./order-dependency\":24,\"./types\":30}],23:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst order_1 = require(\"./order\");\nconst data_1 = require(\"./data\");\nconst Error = require(\"./error\");\nconst { Army, Fleet } = data_1.MilitaryBranch;\nclass MovementValidator {\n    unitsRequiringOrder(board) {\n        return board.units;\n    }\n    errorOfOrder(board, o) {\n        // The order is invalid if order.unit is not in board.\n        if (!board.units.has(o.unit)) {\n            return new Error.UnitNotExisted(o.unit);\n        }\n        if (o instanceof order_1.Hold) {\n            return null;\n        }\n        else if (o instanceof order_1.Move) {\n            // TODO the type of `o` is inferred as `never`\n            const order = o;\n            /*\n            Move is valid if\n            1. the unit can move to the destination or\n            2. the unit is army, the location is coast, and the fleet can move to destination from the location.\n            */\n            if (utils_1.Utils.movableLocationsOf(board, order.unit).has(order.destination)) {\n                return null;\n            }\n            else {\n                return new Error.UnmovableLocation(order.unit, order.destination);\n            }\n        }\n        else if (o instanceof order_1.Support) {\n            const order = o;\n            // Support is valid if the destination can be moved.\n            const msgForTarget = this.errorOfOrder(board, order.target);\n            if (msgForTarget) {\n                return msgForTarget;\n            }\n            else {\n                if (utils_1.Utils.supportableLocationsOf(board.map, order.unit).has(order.destination)) {\n                    return null;\n                }\n                else {\n                    return new Error.UnsupportableLocation(order.unit, order.destination);\n                }\n            }\n        }\n        else if (o instanceof order_1.Convoy) {\n            const order = o;\n            /*\n            Convoy is valid if\n            1. the unit is fleet,\n            2. the target is move order,\n            3. the target is army,\n            4. the location is sea, and\n            5. the destination can be moved from the unit's location\n            */\n            const msg = this.errorOfOrder(board, order.target);\n            if (msg) {\n                return msg;\n            }\n            else {\n                if (order.unit.militaryBranch !== Fleet) {\n                    return new Error.CannotBeOrdered(order);\n                }\n                else if (order.target.unit.militaryBranch !== Army) {\n                    return new Error.CannotBeOrdered(order);\n                }\n                else {\n                    if (!utils_1.Utils.isSea(board.map, order.unit.location.province)) {\n                        return new Error.CannotBeOrdered(order);\n                    }\n                    else if (!utils_1.Utils.isMovableViaSea(board.map, order.target.unit.location.province, order.target.destination.province, board.units)) {\n                        return new Error.UnmovableLocation(order.target.unit, order.target.destination);\n                    }\n                    else if (!(board.map.movableProvincesOf(order.unit.location.province, Fleet).has(order.target.destination.province) ||\n                        utils_1.Utils.isMovableViaSea(board.map, order.unit.location.province, order.target.destination.province, board.units))) {\n                        return new Error.UnconvoyableLocation(order.unit, order.target.destination);\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            }\n        }\n        return new Error.InvalidPhase(o);\n    }\n    errorOfOrders(board, orders) {\n        return null;\n    }\n}\nexports.MovementValidator = MovementValidator;\n\n},{\"./data\":16,\"./error\":17,\"./order\":25,\"./utils\":31}],24:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst order_1 = require(\"./order\");\nconst data_1 = require(\"./data\");\nconst graph_1 = require(\"./../graph\");\nconst board_1 = require(\"./../board\");\nconst { DirectedGraph, Edge } = graph_1.graph;\nconst { Province } = board_1.board;\nclass OrderDependency {\n    constructor(ordersWithResult) {\n        const nodeMap = new Map();\n        const nodes = new Set();\n        const edges = new Set();\n        function addNode(p1) {\n            if (nodeMap.has(p1)) {\n                return;\n            }\n            const n1 = new Set([p1]);\n            nodeMap.set(p1, n1);\n            nodes.add(n1);\n        }\n        function addEdge(p1, p2) {\n            const n1 = nodeMap.get(p1);\n            const n2 = nodeMap.get(p2);\n            if (n1 && n2) {\n                edges.add(new Edge(n1, n2));\n            }\n        }\n        const os = [...ordersWithResult];\n        os.forEach(orderWithResult => {\n            const order = orderWithResult.order;\n            addNode(order.unit.location.province);\n            if (order instanceof order_1.Hold) {\n            }\n            else if (order instanceof order_1.Move) {\n                const o = order;\n                addNode(o.destination.province);\n                addEdge(o.destination.province, o.unit.location.province);\n            }\n            else if (order instanceof order_1.Support) {\n                const o = order;\n                if (orderWithResult.getResult() !== data_1.Result.NoCorrespondingOrder) {\n                    addNode(o.destination.province);\n                    addEdge(o.unit.location.province, o.destination.province);\n                }\n            }\n            else if (order instanceof order_1.Convoy) {\n                const o = order;\n                if (orderWithResult.getResult() !== data_1.Result.NoCorrespondingOrder) {\n                    addNode(o.target.destination.province);\n                    addEdge(o.unit.location.province, o.target.destination.province);\n                }\n            }\n        });\n        let graph = new DirectedGraph(edges, nodes);\n        while (true) {\n            const c = graph.getCycle();\n            if (c && c.length > 1) {\n                graph = graph.mergeNodes(new Set([...c]));\n            }\n            else {\n                break;\n            }\n        }\n        this.graph = graph;\n    }\n}\nexports.OrderDependency = OrderDependency;\n\n},{\"./../board\":2,\"./../graph\":3,\"./data\":16,\"./order\":25}],25:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OrderType;\n(function (OrderType) {\n    OrderType[OrderType[\"Hold\"] = 1] = \"Hold\";\n    OrderType[OrderType[\"Move\"] = 2] = \"Move\";\n    OrderType[OrderType[\"Support\"] = 3] = \"Support\";\n    OrderType[OrderType[\"Convoy\"] = 4] = \"Convoy\";\n    OrderType[OrderType[\"Retreat\"] = 5] = \"Retreat\";\n    OrderType[OrderType[\"Disband\"] = 6] = \"Disband\";\n    OrderType[OrderType[\"Build\"] = 7] = \"Build\";\n})(OrderType = exports.OrderType || (exports.OrderType = {}));\n/**\n * Order of the standard rule\n */\nclass Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     * @param tpe The type of the order\n     */\n    constructor(unit, tpe) {\n        this.unit = unit;\n        this.tpe = tpe;\n    }\n}\nexports.Order = Order;\n/**\n * Hold order\n */\nclass Hold extends Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     */\n    constructor(unit) {\n        super(unit, OrderType.Hold);\n    }\n    toString() {\n        return `${this.unit} H`;\n    }\n}\nexports.Hold = Hold;\n/**\n * Move order\n */\nclass Move extends Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     * @param destination The destination of this move order.\n     * @param useConvoy The flag whether this move order uses convoy or not.\n     */\n    constructor(unit, destination, useConvoy) {\n        super(unit, OrderType.Move);\n        this.destination = destination;\n        this.useConvoy = useConvoy || false;\n    }\n    toString() {\n        if (this.useConvoy) {\n            return `${this.unit}-${this.destination} via Convoy`;\n        }\n        else {\n            return `${this.unit}-${this.destination}`;\n        }\n    }\n}\nexports.Move = Move;\n/**\n * Support order\n */\nclass Support extends Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     * @param target The target order of this support.\n     */\n    constructor(unit, target) {\n        super(unit, OrderType.Support);\n        this.target = target;\n        console.assert(target.tpe === OrderType.Move || target.tpe === OrderType.Hold);\n        if (target instanceof Move) {\n            this.destination = target.destination;\n        }\n        else {\n            this.destination = target.unit.location;\n        }\n    }\n    toString() {\n        return `${this.unit} S ${this.target}`;\n    }\n}\nexports.Support = Support;\n/**\n * Convoy order\n */\nclass Convoy extends Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     * @param target The target order of this convoy.\n     */\n    constructor(unit, target) {\n        super(unit, OrderType.Convoy);\n        this.target = target;\n        console.assert(target.tpe === OrderType.Move);\n    }\n    toString() {\n        return `${this.unit} C ${this.target}`;\n    }\n}\nexports.Convoy = Convoy;\n/**\n * Retreat order\n */\nclass Retreat extends Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     * @param destination The destination of this retreat.\n     */\n    constructor(unit, destination) {\n        super(unit, OrderType.Retreat);\n        this.destination = destination;\n    }\n    toString() {\n        return `${this.unit} R ${this.destination}`;\n    }\n}\nexports.Retreat = Retreat;\n/**\n * Disband order\n */\nclass Disband extends Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     */\n    constructor(unit) {\n        super(unit, OrderType.Disband);\n    }\n    toString() {\n        return `Disband ${this.unit}`;\n    }\n}\nexports.Disband = Disband;\n/**\n * Build order\n */\nclass Build extends Order {\n    /**\n     * @param unit The unit that corresponds to this order.\n     */\n    constructor(unit) {\n        super(unit, OrderType.Build);\n    }\n    toString() {\n        return `Build ${this.unit}`;\n    }\n}\nexports.Build = Build;\n\n},{}],26:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst order_1 = require(\"./order\");\nclass RetreatOrderGenerator {\n    ordersToSkipPhase(board) {\n        if (board.unitStatuses.size === 0) {\n            return new Set();\n        }\n        if ([...board.unitStatuses].every(elem => {\n            const [unit, status] = elem;\n            const locations = utils_1.Utils.locationsToRetreat(board, unit, status.attackedFrom);\n            return locations.size === 0;\n        })) {\n            // Disband all dislodged units\n            const retval = new Set();\n            board.unitStatuses.forEach((status, unit) => {\n                retval.add(new order_1.Disband(unit));\n            });\n            return retval;\n        }\n        return null;\n    }\n    defaultOrderOf(board, unit) {\n        return new order_1.Disband(unit);\n    }\n}\nexports.RetreatOrderGenerator = RetreatOrderGenerator;\n\n},{\"./order\":25,\"./utils\":31}],27:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst data_1 = require(\"./data\");\nconst order_1 = require(\"./order\");\nconst utils_1 = require(\"./utils\");\nconst types_1 = require(\"./types\");\nconst board_1 = require(\"./../board\");\nconst rule_1 = require(\"./../rule\");\nconst util_1 = require(\"./../util\");\nconst { Province } = board_1.board;\nconst { Executed } = rule_1.rule;\nconst { Success } = util_1.util;\nconst { Movement, Build } = data_1.Phase;\nclass RetreatResolver {\n    resolve(board, orders) {\n        const disbands = [...orders].filter(order => order.tpe === order_1.OrderType.Disband);\n        const retreats = ([...orders].filter(order => order.tpe === order_1.OrderType.Retreat));\n        const retval = new Map();\n        disbands.forEach(order => retval.set(order, data_1.Result.Success));\n        // Create a map from province to retreat order\n        const province2RetreatUnits = new Map();\n        retreats.forEach(order => {\n            const elem = province2RetreatUnits.get(order.destination.province) || [];\n            elem.push(order);\n            province2RetreatUnits.set(order.destination.province, elem);\n        });\n        // Resolve retreat orders\n        province2RetreatUnits.forEach((orders, province) => {\n            if (orders.length === 1) {\n                orders.forEach(order => retval.set(order, data_1.Result.Success));\n            }\n            else {\n                orders.forEach(order => retval.set(order, data_1.Result.Failed));\n            }\n        });\n        // Generate a new board\n        const unit2Result = new Map([...retval].map(elem => {\n            return [elem[0].unit, [elem[0], elem[1]]];\n        }));\n        const newUnits = new Set();\n        board.units.forEach(unit => {\n            const result = unit2Result.get(unit);\n            if (result) {\n                const [order, r] = result;\n                if (order instanceof order_1.Retreat && r === data_1.Result.Success) {\n                    newUnits.add(new types_1.Unit(unit.militaryBranch, order.destination, unit.power));\n                }\n            }\n            else {\n                newUnits.add(unit);\n            }\n        });\n        const newState = (board.state.turn.isBuildable)\n            ? new data_1.State(board.state.turn, Build)\n            : new data_1.State(board.state.turn.nextTurn(), Movement);\n        // Update occupation if needed\n        const occupationStatuses = [...board.provinceStatuses]\n            .filter(elem => elem[1].occupied)\n            .map(elem => {\n            if (elem[1].standoff) {\n                return [elem[0], new data_1.ProvinceStatus(elem[1].occupied, false)];\n            }\n            else {\n                return elem;\n            }\n        });\n        const newProvinceStatuses = new Map([...occupationStatuses]);\n        if (board.state.turn.isOccupationUpdateable) {\n            newUnits.forEach(unit => {\n                newProvinceStatuses.set(unit.location.province, new data_1.ProvinceStatus(unit.power, false));\n            });\n        }\n        const newBoard = new types_1.Board(board.map, newState, newUnits, [], newProvinceStatuses);\n        const orderResults = [...retval].map(elem => {\n            const [order, result] = elem;\n            return new Executed(order, result);\n        });\n        const numOfCenters = ([...board.map.provinces].filter(p => p.isSupplyCenter)).length;\n        const numberOfSupplyCenters = utils_1.Utils.numberOfSupplyCenters(newBoard);\n        const isFinished = [...newBoard.map.powers].some(power => {\n            return (numberOfSupplyCenters.get(power) || 0) > (numOfCenters / 2);\n        });\n        return new Success(new types_1.ResolvedResult(newBoard, orderResults, isFinished));\n    }\n}\nexports.RetreatResolver = RetreatResolver;\n\n},{\"./../board\":2,\"./../rule\":5,\"./../util\":32,\"./data\":16,\"./order\":25,\"./types\":30,\"./utils\":31}],28:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\nconst order_1 = require(\"./order\");\nconst Error = require(\"./error\");\nclass RetreatValidator {\n    unitsRequiringOrder(board) {\n        return new Set([...board.unitStatuses].map(elem => elem[0]));\n    }\n    errorOfOrder(board, order) {\n        // The order is invalid if order.unit is not dislodged\n        const dislodged = board.unitStatuses.get(order.unit);\n        if (!dislodged) {\n            return new Error.CannotBeOrdered(order);\n        }\n        if (order instanceof order_1.Retreat) {\n            const ls = utils_1.Utils.locationsToRetreat(board, order.unit, dislodged.attackedFrom);\n            if (!ls.has(order.destination)) {\n                return new Error.UnmovableLocation(order.unit, order.destination);\n            }\n        }\n        else if (!(order instanceof order_1.Disband)) {\n            return new Error.InvalidPhase(order);\n        }\n        return null;\n    }\n    errorOfOrders(board, orders) {\n        for (let elem of [...board.unitStatuses]) {\n            const [unit, status] = elem;\n            const hasOrder = [...orders].some(order => order.unit === unit);\n            if (!hasOrder) {\n                return new Error.OrderNotExisted(unit);\n            }\n        }\n        return null;\n    }\n}\nexports.RetreatValidator = RetreatValidator;\n\n},{\"./error\":17,\"./order\":25,\"./utils\":31}],29:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst types_1 = require(\"./types\");\nconst data_1 = require(\"./data\");\nconst movement_resolver_1 = require(\"./movement-resolver\");\nconst movement_validator_1 = require(\"./movement-validator\");\nconst movement_order_generator_1 = require(\"./movement-order-generator\");\nconst retreat_resolver_1 = require(\"./retreat-resolver\");\nconst retreat_validator_1 = require(\"./retreat-validator\");\nconst retreat_order_generator_1 = require(\"./retreat-order-generator\");\nconst build_resolver_1 = require(\"./build-resolver\");\nconst build_validator_1 = require(\"./build-validator\");\nconst build_order_generator_1 = require(\"./build-order-generator\");\nconst error_1 = require(\"./error\");\nconst rule_1 = require(\"./../rule\");\nconst util_1 = require(\"./../util\");\nconst { Success, Failure } = util_1.util;\nconst { Movement, Retreat, Build } = data_1.Phase;\nclass PhaseRule {\n    constructor(resolver, validator, orderGenerator) {\n        this.resolver = resolver;\n        this.validator = validator;\n        this.orderGenerator = orderGenerator;\n    }\n}\n/**\n * Standard rule of Diplomacy\n */\nclass Rule extends rule_1.rule.Rule {\n    /**\n     * @param stringify Stringify instances of Power\n     */\n    constructor() {\n        super();\n        this.phaseRules = new Map([\n            [\n                Movement,\n                new PhaseRule(new movement_resolver_1.MovementResolver(), new movement_validator_1.MovementValidator(), new movement_order_generator_1.MovementOrderGenerator())\n            ],\n            [\n                Retreat,\n                new PhaseRule(new retreat_resolver_1.RetreatResolver(), new retreat_validator_1.RetreatValidator(), new retreat_order_generator_1.RetreatOrderGenerator())\n            ],\n            [\n                Build,\n                new PhaseRule(new build_resolver_1.BuildResolver(), new build_validator_1.BuildValidator(), new build_order_generator_1.BuildOrderGenerator())\n            ]\n        ]);\n    }\n    resolveProcedure(board, orders) {\n        const unitsHaveSeveralOrders = new Set([...orders].filter(order => {\n            return [...orders].some(order2 => order !== order2 && order.unit === order2.unit);\n        }).map(order => order.unit));\n        if (unitsHaveSeveralOrders.size !== 0) {\n            return new Failure(new error_1.SeveralOrders(unitsHaveSeveralOrders));\n        }\n        const ruleOpt = this.phaseRules.get(board.state.phase);\n        if (!ruleOpt) {\n            throw `invalid phase: ${board.state.phase}`;\n        }\n        const { resolver } = ruleOpt;\n        const r1 = resolver.resolve(board, orders);\n        if (!r1.result) {\n            return r1;\n        }\n        const result = r1.result;\n        const ruleOpt2 = this.phaseRules.get(result.board.state.phase);\n        if (!ruleOpt2) {\n            throw `Invalid phase: ${result.board.state.phase}`;\n        }\n        const orders2 = ruleOpt2.orderGenerator.ordersToSkipPhase(result.board);\n        if (!orders2) {\n            return r1;\n        }\n        const r2 = this.resolve(result.board, orders2);\n        if (!r2.result) {\n            return r2;\n        }\n        const result2 = r2.result;\n        const orderResults = new Set([...result.results]);\n        result2.results.forEach(r => orderResults.add(r));\n        return new Success(new types_1.ResolvedResult(result2.board, orderResults, result.isFinished || result2.isFinished));\n    }\n    unitsRequiringOrder(board) {\n        const ruleOpt = this.phaseRules.get(board.state.phase);\n        if (!ruleOpt) {\n            throw `invalid phase: ${board.state.phase}`;\n        }\n        return ruleOpt.validator.unitsRequiringOrder(board);\n    }\n    errorOfOrder(board, order) {\n        const ruleOpt = this.phaseRules.get(board.state.phase);\n        if (!ruleOpt) {\n            throw `invalid phase: ${board.state.phase}`;\n        }\n        return ruleOpt.validator.errorOfOrder(board, order);\n    }\n    errorOfOrders(board, orders) {\n        const ruleOpt = this.phaseRules.get(board.state.phase);\n        if (!ruleOpt) {\n            throw `invalid phase: ${board.state.phase}`;\n        }\n        return ruleOpt.validator.errorOfOrders(board, orders);\n    }\n    defaultOrderOf(board, unit) {\n        const ruleOpt = this.phaseRules.get(board.state.phase);\n        if (!ruleOpt) {\n            throw `invalid phase: ${board.state.phase}`;\n        }\n        return ruleOpt.orderGenerator.defaultOrderOf(board, unit);\n    }\n}\nexports.Rule = Rule;\n\n},{\"./../rule\":5,\"./../util\":32,\"./build-order-generator\":13,\"./build-resolver\":14,\"./build-validator\":15,\"./data\":16,\"./error\":17,\"./movement-order-generator\":19,\"./movement-resolver\":22,\"./movement-validator\":23,\"./retreat-order-generator\":26,\"./retreat-resolver\":27,\"./retreat-validator\":28,\"./types\":30}],30:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst board_1 = require(\"./../board\");\nconst rule_1 = require(\"./../rule\");\nconst data_1 = require(\"./data\");\nclass Location extends board_1.board.Location {\n}\nexports.Location = Location;\nclass Unit extends board_1.board.Unit {\n    toString() {\n        switch (this.militaryBranch) {\n            case data_1.MilitaryBranch.Army:\n                return `A ${this.location}`;\n            case data_1.MilitaryBranch.Fleet:\n                return `F ${this.location}`;\n        }\n    }\n}\nexports.Unit = Unit;\nclass DiplomacyMap extends board_1.board.DiplomacyMap {\n}\nexports.DiplomacyMap = DiplomacyMap;\nclass Board extends board_1.board.Board {\n}\nexports.Board = Board;\nclass ResolvedResult extends rule_1.rule.ResolvedResult {\n}\nexports.ResolvedResult = ResolvedResult;\n\n},{\"./../board\":2,\"./../rule\":5,\"./data\":16}],31:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst board_1 = require(\"./../board\");\nconst data_1 = require(\"./data\");\nconst { Province } = board_1.board;\n/*\n/**\n * Utility of the standard rule\n */\nclass Utils {\n    /**\n     * @param board -\n     * @returns The map between powers and the number of supply centers\n     */\n    static numberOfSupplyCenters(board) {\n        const retval = new Map();\n        board.provinceStatuses.forEach((status, province) => {\n            if (!status.occupied) {\n                return;\n            }\n            const power = status.occupied;\n            if (power) {\n                const numOfSupply = retval.get(power) || 0;\n                retval.set(power, numOfSupply + ((province.isSupplyCenter) ? 1 : 0));\n            }\n        });\n        return retval;\n    }\n    /**\n     * @returns True if the province is sea. Sea is a province that only Fleet can enter.\n     */\n    static isSea(map, province) {\n        return [...map.locationsOf(province)].every(l => {\n            return l.militaryBranches.size === 1 && l.militaryBranches.has(data_1.MilitaryBranch.Fleet);\n        });\n    }\n    /**\n     * @return True if the unit can be ordered \"convoy\" order.\n     */\n    static canConvoy(map, unit) {\n        return Utils.isSea(map, unit.location.province);\n    }\n    /**\n     * @returns The locations that the unit can retreat to.\n     */\n    static locationsToRetreat(board, unit, attackedFrom) {\n        return new Set([...board.map.movableLocationsOf(unit.location, unit.militaryBranch)].filter(location => {\n            const existsUnit = [...board.units].some(unit => unit.location.province === location.province);\n            const status = board.provinceStatuses.get(location.province);\n            if (status && status.standoff) {\n                return false;\n            }\n            else if (location.province === attackedFrom) {\n                return false;\n            }\n            else if (existsUnit) {\n                return false;\n            }\n            else {\n                return true;\n            }\n        }));\n    }\n    /**\n     * @param units The set of units that is used for convoy\n     */\n    static isMovableViaSea(map, source, destination, units) {\n        const provinces = new Set([...units]\n            .filter(u => u.militaryBranch === data_1.MilitaryBranch.Fleet)\n            .map(x => x.location.province));\n        const visited = new Set();\n        // TODO duplicated code\n        function dfs(province) {\n            const nextProvinces = [...map.movableProvincesOf(province, data_1.MilitaryBranch.Fleet)]\n                .filter(p => Utils.isSea(map, p) && provinces.has(p));\n            return nextProvinces.some(p => {\n                if (map.movableProvincesOf(p, data_1.MilitaryBranch.Fleet).has(destination)) {\n                    return true;\n                }\n                else if (!visited.has(p)) {\n                    visited.add(p);\n                    return dfs(p);\n                }\n                else {\n                    return false;\n                }\n            });\n        }\n        return dfs(source);\n    }\n    /**\n     * @returns The location that the unit can move via convoy\n     */\n    static movableViaConvoyLocationsOf(board, unit) {\n        if (unit.militaryBranch === data_1.MilitaryBranch.Fleet) {\n            return new Set();\n        }\n        const provinces = new Set([...board.units].map(x => x.location.province));\n        const visited = new Set();\n        // TODO duplicated code\n        function dfs(province) {\n            const nextProvinces = [...board.map.movableProvincesOf(province, data_1.MilitaryBranch.Fleet)]\n                .filter(p => Utils.isSea(board.map, p) && provinces.has(p));\n            nextProvinces.forEach(p => {\n                if (!visited.has(p)) {\n                    visited.add(p);\n                    dfs(p);\n                }\n            });\n        }\n        dfs(unit.location.province);\n        // The provinces that can use for convoy\n        const sea = visited;\n        let retval = [];\n        sea.forEach(s => {\n            [...board.map.movableProvincesOf(s, data_1.MilitaryBranch.Fleet)]\n                .filter(p => !Utils.isSea(board.map, p))\n                .forEach(p => {\n                board.map.locationsOf(p).forEach(l => {\n                    if (l.militaryBranches.has(data_1.MilitaryBranch.Army)) {\n                        retval.push(l);\n                    }\n                });\n            });\n        });\n        return new Set(retval.filter(x => x.province !== unit.location.province));\n    }\n    /**\n     * @returns The locations that the unit can move to (including via convoy).\n     */\n    static movableLocationsOf(board, unit) {\n        const locations = Array.from(board.map.movableLocationsOf(unit.location, unit.militaryBranch));\n        const movableViaSea = Utils.movableViaConvoyLocationsOf(board, unit);\n        return new Set(Array.from(movableViaSea).concat(locations));\n    }\n    /**\n     * @return The set of locations that can be supported by the unit\n     */\n    static supportableLocationsOf(map, unit) {\n        const provinces = new Set(Array.from(map.movableLocationsOf(unit.location, unit.militaryBranch)).map(l => l.province));\n        const retval = new Set();\n        provinces.forEach(p => {\n            map.locationsOf(p).forEach(l => retval.add(l));\n        });\n        return retval;\n    }\n    /**\n     * @return\n     *   The Map between powers and number of buildable units.\n     *   If a power should disband some units, this contains negative number\n     *   (e.g., It contains -1 if a power has to disband 1 unit).\n     */\n    static numberOfBuildableUnits(board) {\n        const numberOfSupplyCenters = Utils.numberOfSupplyCenters(board);\n        const retval = new Map();\n        board.map.powers.forEach(power => {\n            const numOfSupply = numberOfSupplyCenters.get(power) || 0;\n            const numOfUnits = ([...board.units].filter(x => x.power === power)).length;\n            retval.set(power, numOfSupply - numOfUnits);\n        });\n        return retval;\n    }\n}\nexports.Utils = Utils;\n\n},{\"./../board\":2,\"./data\":16}],32:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util;\n(function (util) {\n    class Success {\n        constructor(result) {\n            this.result = result;\n        }\n    }\n    util.Success = Success;\n    class Failure {\n        constructor(err) {\n            this.err = err;\n        }\n    }\n    util.Failure = Failure;\n})(util = exports.util || (exports.util = {}));\n\n},{}],33:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar variant;\n(function (variant) {\n    /**\n     * Variant of Diplomacy\n     */\n    class Variant {\n        /**\n         * @param rule The rule used in this variant.\n         * @param initialBoard The initial state of the board used in this variant.\n         */\n        constructor(rule, initialBoard) {\n            this.rule = rule;\n            this.initialBoard = initialBoard;\n        }\n    }\n    variant.Variant = Variant;\n})(variant = exports.variant || (exports.variant = {}));\n\n},{}]},{},[1]);\n"],"file":"diplomacy.js"}